<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="小飞哥的个人博客主页"><meta name="keywords" content=""><meta name="author" content="flueky"><meta name="copyright" content="flueky"><title>Android 程序猿秘籍 | Flueky 技术小站</title><link rel="shortcut icon" href="/test/melody-favicon.ico"><link rel="stylesheet" href="/test/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/test/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/test/img/avatar.png"></div><div class="author-info__name text-center">flueky</div><div class="author-info__description text-center">小飞哥的个人博客主页</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/test/archives"><span class="pull-left">Articles</span><span class="pull-right">63</span></a><a class="author-info-articles__tags article-meta" href="/test/tags"><span class="pull-left">Tags</span><span class="pull-right">20</span></a><a class="author-info-articles__categories article-meta" href="/test/categories"><span class="pull-left">Categories</span><span class="pull-right">11</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/test/">Flueky 技术小站</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right"></span></div><div id="site-info"><div id="site-title">Flueky 技术小站</div><div id="site-sub-title">Android 程序猿秘籍</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/test/233/">浅谈 Java 中的排序</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-10-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/Java/">Java</a></span><div class="content"><p>进来不要失望，这不是一篇讲排序算法的文章。而是简要介绍 Java 中排序相关的类<code>Comparator</code>、<code>Comparable</code>以及<code>Collections.sort</code>的使用。</p></div><a class="more" href="/test/233/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/test/232/">优化Android Log类，并保存日志内容至文件</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-08-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/Android/">Android</a></span><div class="content"><h2 id="1-目的何在"><a href="#1-目的何在" class="headerlink" title="1 目的何在"></a>1 目的何在</h2><p>为什么要优化log？举两个例子。</p>
<p>开发中遇到问题时，我们喜欢用log帮助自己分析问题，通常没有在解决问题之后删除日志输出代码的习惯，那么问题来了。别人也可以根据你开发时的日志信息来分析你程序的漏洞，所以安全公司一般建议在release包中删除日志输入代码。这时候不可能逐行删除（<strong>工作量太大</strong>）。</p>
<p>安卓系统更新快，机型多且杂。考虑到兼容性问题，那么至少在主流的几个OS版本和品牌手机上测试。即使是专业的IT公司有足够的设备供你测试，也相信你是希望将这份测试工作交给专业的测试人员负责。这时候出现问题，总不能叫别人把手机拿过来给你连上电脑调试。因此有必要将日志输出内存保存至文件，然后直接分析日志文件即可。</p>
<p>所以，接下来看如何进行封装。</p>
<h2 id="2-枚举日志级别"><a href="#2-枚举日志级别" class="headerlink" title="2 枚举日志级别"></a>2 枚举日志级别</h2><p>分析原生log类，常用日志级别有6个，从依次是VERBOSE、DEBUG、INFO、WARN、ERROR、ASSERT，6个值依次对应6个整型常量。</p>
<p>依此生成7个枚举变量（<strong>新增CLOSE</strong>，用来生成release包时，不输出日志）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 日志级别</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Level</span> &#123;</span><br><span class="line"></span><br><span class="line">    VERBOSE(Log.VERBOSE),</span><br><span class="line"></span><br><span class="line">    DEBUG(Log.DEBUG),</span><br><span class="line"></span><br><span class="line">    INFO(Log.INFO),</span><br><span class="line"></span><br><span class="line">    WARN(Log.WARN),</span><br><span class="line"></span><br><span class="line">    ERROR(Log.ERROR),</span><br><span class="line"></span><br><span class="line">    ASSERT(Log.ASSERT),</span><br><span class="line"></span><br><span class="line">    CLOSE(Log.ASSERT + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    Level(<span class="type">int</span> value) &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-封装原生方法"><a href="#3-封装原生方法" class="headerlink" title="3 封装原生方法"></a>3 封装原生方法</h2><p>封装有三个目的：</p>
<ol>
<li>关于TAG，每次都需要申明一个静态常量或者每次写一个参数。重载函数，将参数String改成Object，这样可以直接用this关键字传递类对象并通过<code>target.getClass().getSimpleName()</code>获取类名称做TAG。</li>
<li>之前申明7个枚举变量，用作日志筛选和关闭日志输出，因此在调用原生6个日志输出函数之前添加筛选逻辑代码。</li>
<li>保存日志至问价有两个方式：用logcat命令（AS和eclipse的日志窗口使用）、在日志函数调用前手动保存。这里重点介绍该方式。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">i</span><span class="params">(String tag, String msg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentLevel.value &gt; Level.INFO.value)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (isWriter) &#123;</span><br><span class="line">        write(tag, msg, <span class="string">&quot;I&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Log.i(tag, msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">i</span><span class="params">(String tag, String msg, Throwable throwable)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentLevel.value &gt; Level.INFO.value)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (isWriter) &#123;</span><br><span class="line">        write(tag, msg, <span class="string">&quot;I&quot;</span>, throwable);</span><br><span class="line">    &#125;</span><br><span class="line">    Log.i(tag, msg, throwable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">v</span><span class="params">(String tag, String msg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentLevel.value &gt; Level.VERBOSE.value)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (isWriter) &#123;</span><br><span class="line">        write(tag, msg, <span class="string">&quot;V&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Log.v(tag, msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">v</span><span class="params">(String tag, String msg, Throwable throwable)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentLevel.value &gt; Level.VERBOSE.value)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (isWriter) &#123;</span><br><span class="line">        write(tag, msg, <span class="string">&quot;V&quot;</span>, throwable);</span><br><span class="line">    &#125;</span><br><span class="line">    Log.v(tag, msg, throwable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">d</span><span class="params">(String tag, String msg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentLevel.value &gt; Level.DEBUG.value)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (isWriter) &#123;</span><br><span class="line">        write(tag, msg, <span class="string">&quot;D&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Log.d(tag, msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">d</span><span class="params">(String tag, String msg, Throwable throwable)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentLevel.value &gt; Level.DEBUG.value)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (isWriter) &#123;</span><br><span class="line">        write(tag, msg, <span class="string">&quot;D&quot;</span>, throwable);</span><br><span class="line">    &#125;</span><br><span class="line">    Log.d(tag, msg, throwable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">e</span><span class="params">(String tag, String msg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentLevel.value &gt; Level.ERROR.value)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (isWriter) &#123;</span><br><span class="line">        write(tag, msg, <span class="string">&quot;E&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Log.e(tag, msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">e</span><span class="params">(String tag, String msg, Throwable throwable)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentLevel.value &gt; Level.ERROR.value)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (isWriter) &#123;</span><br><span class="line">        write(tag, msg, <span class="string">&quot;E&quot;</span>, throwable);</span><br><span class="line">    &#125;</span><br><span class="line">    Log.e(tag, msg, throwable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">w</span><span class="params">(String tag, String msg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentLevel.value &gt; Level.WARN.value)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (isWriter) &#123;</span><br><span class="line">        write(tag, msg, <span class="string">&quot;W&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Log.w(tag, msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">w</span><span class="params">(String tag, String msg, Throwable throwable)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentLevel.value &gt; Level.WARN.value)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (isWriter) &#123;</span><br><span class="line">        write(tag, msg, <span class="string">&quot;W&quot;</span>, throwable);</span><br><span class="line">    &#125;</span><br><span class="line">    Log.w(tag, msg, throwable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">i</span><span class="params">(Object target, String msg)</span> &#123;</span><br><span class="line">    i(target.getClass().getSimpleName(), msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">i</span><span class="params">(Object target, String msg, Throwable throwable)</span> &#123;</span><br><span class="line">    i(target.getClass().getSimpleName(), msg, throwable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">v</span><span class="params">(Object target, String msg)</span> &#123;</span><br><span class="line">    v(target.getClass().getSimpleName(), msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">v</span><span class="params">(Object target, String msg, Throwable throwable)</span> &#123;</span><br><span class="line">    v(target.getClass().getSimpleName(), msg, throwable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">d</span><span class="params">(Object target, String msg)</span> &#123;</span><br><span class="line">    d(target.getClass().getSimpleName(), msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">d</span><span class="params">(Object target, String msg, Throwable throwable)</span> &#123;</span><br><span class="line">    d(target.getClass().getSimpleName(), msg, throwable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">e</span><span class="params">(Object target, String msg)</span> &#123;</span><br><span class="line">    e(target.getClass().getSimpleName(), msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">e</span><span class="params">(Object target, String msg, Throwable throwable)</span> &#123;</span><br><span class="line">    e(target.getClass().getSimpleName(), msg, throwable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">w</span><span class="params">(Object target, String msg)</span> &#123;</span><br><span class="line">    w(target.getClass().getSimpleName(), msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">w</span><span class="params">(Object target, String msg, Throwable throwable)</span> &#123;</span><br><span class="line"></span><br><span class="line">    w(target.getClass().getSimpleName(), msg, throwable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-保存日志内容至文件"><a href="#4-保存日志内容至文件" class="headerlink" title="4 保存日志内容至文件"></a>4 保存日志内容至文件</h2><p>封装原生方法的目的在于，我们可以插入write方法，保存日志内容至文件。<code>LOG_FORMAT</code> 是仿造AS的日志输出格式，后面会附上结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 写文件操作</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> tag       日志标签</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> msg       日志内容</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> level     日志级别</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> throwable 异常捕获</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String tag, String msg, String level, Throwable throwable)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">timeStamp</span> <span class="operator">=</span> LOG_TIME_FORMAT.format(Calendar.getInstance().getTime());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        writer.write(String.format(LOG_FORMAT, timeStamp, Process.myPid(), Process.myTid(), pkgName, level, tag));</span><br><span class="line">        writer.write(msg);</span><br><span class="line">        writer.newLine();</span><br><span class="line">        writer.flush();</span><br><span class="line">        osWriter.flush();</span><br><span class="line">        fos.flush();</span><br><span class="line">        <span class="keyword">if</span> (throwable != <span class="literal">null</span>)</span><br><span class="line">            saveCrash(throwable);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 保存异常</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> throwable</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveCrash</span><span class="params">(Throwable throwable)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">StringWriter</span> <span class="variable">sWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringWriter</span>();</span><br><span class="line">    <span class="type">PrintWriter</span> <span class="variable">pWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(sWriter);</span><br><span class="line">    throwable.printStackTrace(pWriter);</span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> throwable.getCause();</span><br><span class="line">    <span class="keyword">while</span> (cause != <span class="literal">null</span>) &#123;</span><br><span class="line">        cause.printStackTrace(pWriter);</span><br><span class="line">        cause = cause.getCause();</span><br><span class="line">    &#125;</span><br><span class="line">    pWriter.flush();</span><br><span class="line">    pWriter.close();</span><br><span class="line">    sWriter.flush();</span><br><span class="line">    <span class="type">String</span> <span class="variable">crashInfo</span> <span class="operator">=</span> writer.toString();</span><br><span class="line">    sWriter.close();</span><br><span class="line">    writer.write(crashInfo);</span><br><span class="line">    writer.newLine();</span><br><span class="line">    writer.flush();</span><br><span class="line">    osWriter.flush();</span><br><span class="line">    fos.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存的日志内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">08-14 17:15:03.665 24152-24152/com.flueky.app D/TAG:838E512687D20F6B40409A2E3A7B24156774F47C</span><br></pre></td></tr></table></figure>

<h2 id="5-组件初始化"><a href="#5-组件初始化" class="headerlink" title="5 组件初始化"></a>5 组件初始化</h2><ol>
<li>传入上下文是为了获取程序包名和程序的外部缓存目录：<code>/sdcard/Android/data/包名/</code>。这里的日志文件保存目录是：<code>/sdcard/Android/data/包名/log/日志文件</code>。</li>
<li>isWriter 标记是否需要保存日志内容至文件。</li>
<li>level设置日志输出级别。当level 等于CLOSE时，不输出日志也不保存至文件。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 日志组件初始化</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> appCtx   application 上下文</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> isWriter 是否保存文件</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> level    日志级别</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(Context appCtx, <span class="type">boolean</span> isWriter, Level level)</span> &#123;</span><br><span class="line">    currentLevel = level;</span><br><span class="line">    <span class="keyword">if</span> (level == Level.CLOSE) &#123;</span><br><span class="line">        isWriter = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Logger.isWriter = isWriter;</span><br><span class="line">    <span class="keyword">if</span> (!Logger.isWriter) &#123;<span class="comment">//不保存日志到文件</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">logFoldPath</span> <span class="operator">=</span> appCtx.getExternalCacheDir().getAbsolutePath() + <span class="string">&quot;/../log/&quot;</span>;</span><br><span class="line">    pkgName = appCtx.getPackageName();</span><br><span class="line">    <span class="type">File</span> <span class="variable">logFold</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(logFoldPath);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(flag = logFold.exists()))</span><br><span class="line">        flag = logFold.mkdirs();</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        Logger.isWriter = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    logFilePath = logFoldPath + FILE_NAME_FORMAT.format(Calendar.getInstance().getTime()) + <span class="string">&quot;.log&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">logFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(logFilePath);</span><br><span class="line">        <span class="keyword">if</span> (!(flag = logFile.exists()))</span><br><span class="line">            flag = logFile.createNewFile();</span><br><span class="line">        Logger.isWriter = isWriter &amp; flag;</span><br><span class="line">        <span class="keyword">if</span> (Logger.isWriter) &#123;</span><br><span class="line">            fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(logFile);</span><br><span class="line">            osWriter = <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(fos);</span><br><span class="line">            writer = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(osWriter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        Logger.isWriter = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>觉得有用？那打赏一个呗。[去打赏](&#x2F;donate&#x2F;)</strong></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/test/231/">贷款计算公式——java实现</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-08-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/Java/">Java</a></span><div class="content"><p>废话说在前头，本人公司做银行APP，每次写到贷款计算器总是一遍又一遍研究计算公式。N次过后，还是决定写一篇blog分享给大家。</p></div><a class="more" href="/test/231/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/test/230/">保存Android日志到文件</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-08-08</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/Android/">Android</a></span><div class="content"><p>之前写过一篇日志，[《不是安卓工程师，也能看logcat日志》](&#x2F;228)，不仅需要adb环境还要熟悉logcat命令，感觉比较繁琐。现推出升级版，在Service中保存日志服务。同样用到命令<code>logcat -f logpath</code>。在这之前，已有人造过同样的轮子。只是代码更长，功能更完善。比如：监听日志文件大小，超出10M就重新生成日志文件。个人认为，这些功能有些画蛇添足。试问，有谁会从10M日志文件中去找调试信息。so，出一个简化版，方便阅读、方便理解。</p></div><a class="more" href="/test/230/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/test/200/">Android 自定义权限与动态申请权限</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-07-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/Android/">Android</a></span><div class="content"><p>第一次接触安卓权限，是从一个demo开始。有点类似于Hello Word，这次是从一个叫做<code>android.permission.CALL_PHONE</code>的权限，顾名思义打电话。那时候很懵懂，只知道添加上去程序就可以正常运行。不知其然，更不知其所以然。直至工作中遇到越来越多的场景，因此有必要对安卓权限深入研究一番。</p></div><a class="more" href="/test/200/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/test/229/">Android 画布使用之电子签名</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-12-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/Android/">Android</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/test/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/">自定义View</a></span><div class="content"><p>促进小飞哥写代码的动力只有两个。第一个是为了挣钱钱，第二个是为了挣更多的钱。所以毫无疑问，电子签名又是公司最近需要开发的新功能。</p></div><a class="more" href="/test/229/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/test/228/">不是安卓工程师，也能看logcat日志</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-12-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/test/tags/AndroidStudio/">AndroidStudio</a></span><div class="content"><p>写这篇博客的灵感，来自于最近工作的刺激。手上有好几个项目不定期出现问题，而自己又去不了开发现场看日志分析问题、做debug操作。</p></div><a class="more" href="/test/228/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/test/227/">数据结构（五）——二叉树（C语言实现）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-10-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/C-C/">C/C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/test/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a></span><div class="content"><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>之前四篇博客分别介绍了线性结构中的[顺序表](&#x2F;222)、[链表](&#x2F;223)、[栈](&#x2F;225)、[队列](&#x2F;226)。从难度来讲，顺序表到链表是递增的。从实现来讲，栈和队列基于顺序表和链表（<strong>之前栈采用了顺序表的存储结构，队列采用了链表的存储结构</strong>）。此次介绍的二叉树虽是非线性结构的树形结构分支，但在其各个结点遍历的实现上，使用到了栈和队列的特性。</p>
<p><strong>二叉树</strong>是一种特殊的线性结构，每个结点最多只有两个分支，称左孩子结点和右孩子结点。更多关于二叉树的特性，自行查阅资料。接下来只详细的介绍创建二叉树以及二叉树的遍历。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="定义结构"><a href="#定义结构" class="headerlink" title="定义结构"></a>定义结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> TreeType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BitNode</span> &#123;</span><br><span class="line">	TreeType key;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BitNode</span> *left;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BitNode</span> *right;</span><br><span class="line">&#125; BitTree;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>二叉树的结构和双向链表的结构一致，只是双向链表的两个指针构成线性结构，二叉树的两个指针构成非线性结构。</p>
</blockquote>
<h2 id="定义操作"><a href="#定义操作" class="headerlink" title="定义操作"></a>定义操作</h2><h3 id="构造空二叉树"><a href="#构造空二叉树" class="headerlink" title="构造空二叉树"></a>构造空二叉树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造空二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initBitTree</span><span class="params">(BitTree&amp; root)</span> </span>&#123;</span><br><span class="line">	root.left = <span class="literal">NULL</span>;</span><br><span class="line">	root.right = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将根结点的左右两个指针置空。</p>
</blockquote>
<h3 id="创建二叉树"><a href="#创建二叉树" class="headerlink" title="创建二叉树"></a>创建二叉树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建二叉树(按照前序遍历方式构建二叉树)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createBitTree</span><span class="params">(BitTree** parent)</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span> key = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">if</span> (key == <span class="string">&#x27;#&#x27;</span>) &#123; <span class="comment">//输入#表示该节点是叶子节点</span></span><br><span class="line">		*parent = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		*parent = (BitTree*) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BitTree));</span><br><span class="line">		<span class="keyword">if</span> (*parent == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">9</span>);</span><br><span class="line">		(*parent)-&gt;key = key;</span><br><span class="line">		<span class="built_in">createBitTree</span>(&amp;((*parent)-&gt;left));</span><br><span class="line">		<span class="built_in">createBitTree</span>(&amp;((*parent)-&gt;right));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>先序遍历的方式构建二叉树，输入#号表示当前结点的左孩子结点或右孩子结点为空。</p>
</blockquote>
<h3 id="递归先序遍历"><a href="#递归先序遍历" class="headerlink" title="递归先序遍历"></a>递归先序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归先序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrderTraverse</span><span class="params">(BitTree* parent)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (parent != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">visit</span>(*parent);</span><br><span class="line">		<span class="built_in">preOrderTraverse</span>(parent-&gt;left);<span class="comment">//遍历左子树</span></span><br><span class="line">		<span class="built_in">preOrderTraverse</span>(parent-&gt;right);<span class="comment">//遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>先访问根结点，再依次递归访问左子树和右子树</p>
</blockquote>
<h3 id="递归中序遍历"><a href="#递归中序遍历" class="headerlink" title="递归中序遍历"></a>递归中序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归中序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderTraverse</span><span class="params">(BitTree* parent)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (parent != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">inOrderTraverse</span>(parent-&gt;left);<span class="comment">//遍历左子树</span></span><br><span class="line">		<span class="built_in">visit</span>(*parent);</span><br><span class="line">		<span class="built_in">inOrderTraverse</span>(parent-&gt;right);<span class="comment">//遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>先递归遍历左子树，再访问根节点，最后递归访问右子树。</p>
</blockquote>
<h3 id="递归后序遍历"><a href="#递归后序遍历" class="headerlink" title="递归后序遍历"></a>递归后序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归后序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrderTraverse</span><span class="params">(BitTree* parent)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (parent != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">postOrderTraverse</span>(parent-&gt;left);<span class="comment">//遍历左子树</span></span><br><span class="line">		<span class="built_in">postOrderTraverse</span>(parent-&gt;right);<span class="comment">//遍历右子树</span></span><br><span class="line">		<span class="built_in">visit</span>(*parent);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>先依次递归访问左子树和右子树，最后访问根结点。</p>
</blockquote>
<p>*<strong>三序遍历的递归方式简单的介绍到这里，三序遍历的非递归方式一个比一个难，这是本人自行思考写出的算法，若说阅读了参考资料那也是很久之前的事情。因此觉得，这三段代码还是很有阅读价值。</strong></p>
<h3 id="非递归先序遍历"><a href="#非递归先序遍历" class="headerlink" title="非递归先序遍历"></a>非递归先序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非递归先序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrderTraverseNormal</span><span class="params">(BitTree* parent)</span> </span>&#123;</span><br><span class="line">	Stack stack;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">initStack</span>(stack) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (parent == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">push</span>(stack, *parent);</span><br><span class="line">	BitTree topNode;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">pop</span>(stack, topNode)) &#123; <span class="comment">//取栈顶元素，访问并出栈</span></span><br><span class="line">		<span class="built_in">visit</span> (node); <span class="comment">//访问栈顶元素</span></span><br><span class="line">		<span class="keyword">if</span> (topNode.right != <span class="literal">NULL</span>) &#123; <span class="comment">//存在右结点，则先将右结点入栈。因为左结点先遍历</span></span><br><span class="line">			<span class="built_in">push</span>(stack, *(topNode.right));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (topNode.left != <span class="literal">NULL</span>) &#123; <span class="comment">//存在左结点，左结点入栈</span></span><br><span class="line">			<span class="built_in">push</span>(stack, *(topNode.left));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>非递归遍历的重点是手动构造递归栈。首先将根结点入栈，然后在while循环中，先将栈顶结点出栈，并依次将该结点的右孩子结点和左孩子结点入栈（如果存在），知道栈为空pop函数返回0 结束循环。</p>
</blockquote>
<h3 id="非递归中序遍历"><a href="#非递归中序遍历" class="headerlink" title="非递归中序遍历"></a>非递归中序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非递归中序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderTraverseNormal</span><span class="params">(BitTree* parent)</span> </span>&#123;</span><br><span class="line">	Stack stack;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">initStack</span>(stack) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (parent == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">push</span>(stack, *parent);</span><br><span class="line">	BitTree topNode;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">top</span>(stack, topNode)) &#123; <span class="comment">//取栈顶结点</span></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 首先，一直遍历到最左边的结点</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">while</span> (topNode.left != <span class="literal">NULL</span>) &#123; <span class="comment">//左孩子结点不为空，入栈</span></span><br><span class="line">			<span class="built_in">push</span>(stack, *(topNode.left));<span class="comment">//左孩子结点入栈</span></span><br><span class="line">			topNode = *(topNode.left);<span class="comment">//看下一个左孩子结点</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 其次，判断其是否存在右孩子结点。</span></span><br><span class="line"><span class="comment">		 * 不存在右孩子结点，直接将该结点出栈</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (flag &amp;&amp; topNode.right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="built_in">pop</span>(stack, topNode);<span class="comment">//出栈</span></span><br><span class="line">			<span class="built_in">visit</span>(topNode);</span><br><span class="line">			flag = <span class="built_in">top</span>(stack, topNode);<span class="comment">//取栈顶结点，继续判断</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 存在右孩子结点，当前结点出栈，并将右孩子结点入栈</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">pop</span>(stack, topNode)) &#123;</span><br><span class="line">			<span class="built_in">visit</span>(topNode);</span><br><span class="line">			<span class="built_in">push</span>(stack, *(topNode.right));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>先将根结点入栈，然后根据根结点一直寻找到该左子树的最左边结点，访问该结点。如果该结点不存在右子树，直接将该结点出栈，并一直出栈到栈顶的结点存在右子树。此时将栈顶结点出栈，并将该结点的右孩子结点入栈，并寻找到该结点右子树的最左边结点。</p>
</blockquote>
<h3 id="非递归后序遍历"><a href="#非递归后序遍历" class="headerlink" title="非递归后序遍历"></a>非递归后序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非递归后序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrderTraverseNormal</span><span class="params">(BitTree* parent)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 声明两个栈，遍历树的管理栈和备用栈</span></span><br><span class="line"><span class="comment">	 * 备用栈的作用：部分结点存在两次访问的，备用栈是记录第一次访问，然后入栈。</span></span><br><span class="line"><span class="comment">	 * 也可以在结点中添加一个标签记录访问次数，备用栈的设计是为了避免修改结点</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Stack stack, backup;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">initStack</span>(stack) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">initStack</span>(backup) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (parent == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">push</span>(stack, *parent);</span><br><span class="line">	BitTree topNode; <span class="comment">//记录当前栈顶结点</span></span><br><span class="line">	BitTree backupNode; <span class="comment">//记录备用栈的栈顶结点</span></span><br><span class="line">	BitTree lastNode; <span class="comment">//上次访问的结点</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">top</span>(stack, topNode)) &#123; <span class="comment">//取栈顶结点</span></span><br><span class="line">		<span class="type">int</span> flag = <span class="built_in">top</span>(backup, backupNode); <span class="comment">//备用栈的栈顶元素,返回0表示备用栈为空。</span></span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">0</span> || <span class="built_in">compareTreeNode</span>(topNode, backupNode) == <span class="number">0</span>) &#123; <span class="comment">//该结点是第一次访问</span></span><br><span class="line">			<span class="keyword">if</span> (topNode.left != <span class="literal">NULL</span></span><br><span class="line">					&amp;&amp; <span class="built_in">compareTreeNode</span>(*(topNode.left), lastNode) == <span class="number">0</span>) &#123; <span class="comment">//左孩子结点不为空，且上次访问的不是左孩子结点</span></span><br><span class="line">				<span class="built_in">push</span>(stack, *(topNode.left)); <span class="comment">//左孩子结点入栈</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">push</span>(backup, topNode);</span><br><span class="line">			<span class="keyword">if</span> (topNode.right != <span class="literal">NULL</span></span><br><span class="line">					&amp;&amp; <span class="built_in">compareTreeNode</span>(*(topNode.right), lastNode) == <span class="number">0</span>) &#123; <span class="comment">//右孩子结点不为空，且上次访问的不是右孩子结点</span></span><br><span class="line">				<span class="built_in">push</span>(stack, *(topNode.right)); <span class="comment">//右孩子结点入栈</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">//该节结点是第二次访问，直接出栈</span></span><br><span class="line">			<span class="built_in">pop</span>(backup, backupNode); <span class="comment">//备用栈栈顶元素出栈</span></span><br><span class="line">			<span class="built_in">pop</span>(stack, topNode); <span class="comment">//当前栈栈顶元素出栈</span></span><br><span class="line">			<span class="built_in">visit</span>(topNode); <span class="comment">//访问刚出栈的结点</span></span><br><span class="line">			lastNode = topNode; <span class="comment">//记录刚刚访问的结点</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>考虑到后续遍历的特殊性质，根结点会在左孩子结点和右孩子结点出栈时访问两次。多数资料上的实现方式都是通过在每个结点中添加一个标志记录根节点的访问次数。为了维护之前定义好的结构体的完整性。用一个备用栈，完美的解决问题。</p>
</blockquote>
<blockquote>
<p>取递归栈中的栈顶元素和备用栈中的栈顶元素（如果存在）对比，如果相同，就是第二次遍历到该结点。分别将递归栈和备用栈中的栈顶元素出栈，访问并记录当前出栈的结点。如果不相同，就是第一次访问该结点，此时需要考虑当前递归栈中栈顶结点是否存在左子树或右子树以及上次出栈的结点是否是该结点的左孩子结点或右孩子结点。<br>当该结点不存在左子树或上次出栈的结点是该结点的左孩子结点，则标记当前递归栈中的栈顶结点已经访问过一次，将该结点添加到备用栈中。</p>
</blockquote>
<blockquote>
<p>说了这么多，有点绕。经过长时间的思考以及两次优化之后的成果。越是难懂的算法不一定就是最高级的算法，此处 ，不对我的代码做任何评价。</p>
</blockquote>
<h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 层次遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrderTraverse</span><span class="params">(BitTree* parent)</span> </span>&#123;</span><br><span class="line">	Queue queue = <span class="built_in">createQueue</span>();<span class="comment">//创建队列</span></span><br><span class="line">	<span class="built_in">enterQueue</span>(queue, *parent);<span class="comment">//根结点入队</span></span><br><span class="line">	BitTree node;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">exitQueue</span>(queue, node)) &#123;<span class="comment">//队列中结点出队，队列为空，返回0，while循环结束</span></span><br><span class="line">		<span class="built_in">visit</span>(child);<span class="comment">//访问队列中第一个结点</span></span><br><span class="line">		<span class="keyword">if</span> (node.left != <span class="number">0</span>)<span class="comment">//判断是否存在左孩子结点，将左孩子结点入队</span></span><br><span class="line">			<span class="built_in">enterQueue</span>(queue, *node.left);</span><br><span class="line">		<span class="keyword">if</span> (node.right != <span class="number">0</span>)<span class="comment">//判断是否存在右孩子结点，将右孩子结点入队</span></span><br><span class="line">			<span class="built_in">enterQueue</span>(queue, *node.right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>看完前面三个非递归的遍历算法，也许都晕了。层次遍历，没有递归或非递归而言，自顶向下、从左到右访问二叉树中所有的结点。先访问的结点子树上的全部结点一定比后访问结点子树上的全部结点先访问，所以层次遍历用到了队的特性。</p>
</blockquote>
<h3 id="访问结点"><a href="#访问结点" class="headerlink" title="访问结点"></a>访问结点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(BitTree node)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, node.key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这只是模拟访问结点的操作，可根据需要自定定义该函数的功能。</p>
</blockquote>
<p>上述代码中用到的栈和队列中的函数，都是复用了之前博客中介绍的栈和队列的操作函数。只是修改下每个元素的结点类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> STACK_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tree.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INIT_SIZE 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTINCREMENT 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> BitTree StackType; <span class="comment">//栈中每个元素的结点类型是二叉树</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">stackNode</span> &#123;</span><br><span class="line">	StackType *elem; <span class="comment">//存储空间基地址</span></span><br><span class="line">	<span class="type">int</span> length; <span class="comment">//当前长度</span></span><br><span class="line">	<span class="type">int</span> listsize; <span class="comment">//当前分配的存储容量（以sizeof(ElemType)为单位）</span></span><br><span class="line">&#125;Stack;</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> QUEUE_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUEUE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tree.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> BitTree QueueType;<span class="comment">//队列中每个元素的结点类型是二叉树</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LinkQueue</span> &#123;</span><br><span class="line">	QueueType key;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LinkQueue</span> *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">queueNode</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LinkQueue</span> *head; <span class="comment">//队列的头指针</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LinkQueue</span> *end; <span class="comment">//队列的尾指针</span></span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>最后，附上头文件的定义，部分方法未实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * tree.h</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Created on: 2016年9月25日</span></span><br><span class="line"><span class="comment"> *      Author: flueky</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stack.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;queue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TREE_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TREE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> TreeType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BitNode</span> &#123;</span><br><span class="line">	TreeType key;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BitNode</span> *left;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BitNode</span> *right;</span><br><span class="line">&#125; BitTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造空二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initBitTree</span><span class="params">(BitTree&amp;)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 销毁二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destoryBitTree</span><span class="params">(BitTree&amp;)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createBitTree</span><span class="params">(BitTree**)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将二叉树清为空树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearBitTree</span><span class="params">(BitTree&amp;)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归先序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrderTraverse</span><span class="params">(BitTree*)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非递归先序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrderTraverseNormal</span><span class="params">(BitTree*)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归中序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderTraverse</span><span class="params">(BitTree*)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非递归中序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderTraverseNormal</span><span class="params">(BitTree*)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归后序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrderTraverse</span><span class="params">(BitTree*)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非递归后序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrderTraverseNormal</span><span class="params">(BitTree*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 层次遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrderTraverse</span><span class="params">(BitTree*)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 比较两个结点，相同返回1，不同返回0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compareTreeNode</span><span class="params">(BitTree, BitTree)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(BitTree)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TREE_H_ */</span></span></span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/test/226/">数据结构（四）——队列（C语言实现）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-10-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/C-C/">C/C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/test/tags/%E9%98%9F%E5%88%97/">队列</a></span><div class="content"><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>在[栈](&#x2F;225)中提到，队列是操作受限制的特殊的线性表。<br>在队列的一端只能插入元素，这一端叫做队尾。<br>在队列的另一端只能删除元素，这一端叫做队首。</p>
<p>同样举个栗子。<br>在食堂排队打饭，跑的快的同学排在队列的前面，最先打到饭菜。后续到的同学只能依次排列在队尾。买到饭菜的同学离开队列叫做出队，进入队列等候叫做入队。食堂阿姨给队列中第一个同学打饭叫做访问队首元素。</p>
<p>总结：队列有先进先出的特性，FIFO（First In First Out）。每次只能在线性表的两端操作元素。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>考虑到每次出队和入队都要移动队首和队尾指针。若采用顺序存储，将会有可能造成顺序表前段部分存储单元的浪费。虽说可以采用循环队列的方式复用存储单元，若遇到队列满的情况，将队列扩容比较麻烦。因此建议用链表的方式实现队列。</p>
<h2 id="定义结构"><a href="#定义结构" class="headerlink" title="定义结构"></a>定义结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QueueType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LinkQueue</span>&#123;</span><br><span class="line">	QueueType key;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LinkQueue</span> *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">queueNode</span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LinkQueue</span> *head;<span class="comment">//队列的头指针</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LinkQueue</span> *end;<span class="comment">//队列的尾指针</span></span><br><span class="line">&#125;Queue;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里定义了连个结构体，链表和队列。队列中只保存两个指针——<strong>队首</strong>、<strong>队尾</strong>。后面的入队、出队的操作，只需要操作这两个指针就好。</p>
</blockquote>
<h2 id="定义操作"><a href="#定义操作" class="headerlink" title="定义操作"></a>定义操作</h2><h3 id="创建队列"><a href="#创建队列" class="headerlink" title="创建队列"></a>创建队列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Queue <span class="title">createQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Queue queue;</span><br><span class="line">	queue.head = <span class="number">0</span>;</span><br><span class="line">	queue.end = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>采用静态方式分配队列存储单元。初始化队首和队尾指针。</p>
</blockquote>
<h3 id="判断队列是否为空"><a href="#判断队列是否为空" class="headerlink" title="判断队列是否为空"></a>判断队列是否为空</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断队列是否是空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isEmpty</span><span class="params">(Queue queue)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (queue.head == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>队首指针指向空结点，表示队列为空。</p>
</blockquote>
<h3 id="访问队首元素"><a href="#访问队首元素" class="headerlink" title="访问队首元素"></a>访问队首元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取队列第一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getFirst</span><span class="params">(Queue queue, QueueType&amp; elem)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (queue.head == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	elem = queue.head-&gt;key;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>队首指针可作为链表的头结点。通过头结点访问链表的第一个结点。</p>
</blockquote>
<h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 退出队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exitQueue</span><span class="params">(Queue&amp; queue, QueueType&amp; val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">isEmpty</span>(queue) == <span class="number">0</span>) <span class="comment">//空队列</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LinkQueue</span>* node = queue.head;</span><br><span class="line">	queue.head = node-&gt;next;</span><br><span class="line">	node-&gt;next = <span class="number">0</span>;</span><br><span class="line">	val = node-&gt;key;</span><br><span class="line">	<span class="built_in">free</span>(node);</span><br><span class="line">	<span class="keyword">if</span> (queue.head == <span class="number">0</span>)</span><br><span class="line">		queue.end = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过队首指针，删除队列第一个结点。如果删除后队列为空，将队尾指针置空，否则队尾指针仍然指向最后一个元素。队列为空，删除失败，返回0 。删除成功返回1。</p>
</blockquote>
<h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进入队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">enterQueue</span><span class="params">(Queue&amp; queue, QueueType key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LinkQueue</span>* node = (<span class="keyword">struct</span> LinkQueue*) <span class="built_in">malloc</span>(</span><br><span class="line">			<span class="built_in">sizeof</span>(<span class="keyword">struct</span> LinkQueue));</span><br><span class="line">	<span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	node-&gt;key = key;</span><br><span class="line">	node-&gt;next = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (queue.end == <span class="number">0</span>) &#123;</span><br><span class="line">		queue.end = node;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;<span class="comment">//修改队尾指针</span></span><br><span class="line">		queue.end-&gt;next = node;</span><br><span class="line">		queue.end = node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (queue.head == <span class="number">0</span>) &#123;</span><br><span class="line">		queue.head = node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>队列为空时，队首和队尾指针指向同一个结点就好。队列不为空时，修改队尾指针指向新插入的结点。入队成功返回1，入队失败返回0。</p>
</blockquote>
<p>最后附上头文件的定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * queue.h</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Created on: 2016年9月30日</span></span><br><span class="line"><span class="comment"> *      Author: flueky</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> QUEUE_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUEUE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QueueType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LinkQueue</span> &#123;</span><br><span class="line">	QueueType key;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LinkQueue</span> *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">queueNode</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LinkQueue</span> *head; <span class="comment">//队列的头指针</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LinkQueue</span> *end; <span class="comment">//队列的尾指针</span></span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Queue <span class="title">createQueue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断队列是否是空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isEmpty</span><span class="params">(Queue)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取队列第一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getFirst</span><span class="params">(Queue, QueueType&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进入队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">enterQueue</span><span class="params">(Queue&amp;, QueueType)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 退出队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exitQueue</span><span class="params">(Queue&amp;, QueueType&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearQueue</span><span class="params">(Queue)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* QUEUE_H_ */</span></span></span><br></pre></td></tr></table></figure>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/test/225/">数据结构（三）——栈（C语言实现）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-10-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/C-C/">C/C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/test/tags/%E6%A0%88/">栈</a></span><div class="content"><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>在线性表中，根据存储结构可分为：[顺序表](&#x2F;222&#x2F;) 和 [链表](&#x2F;223)。顺序表和链表可以访问任意位置结点，在任意位置插入和删除结点。倘若对上述操作加以限制，如：</p>
<ol>
<li>   在线性表的一端插入、删除、访问结点。</li>
<li>   在线性表的一端插入结点、另一端删除、访问结点。</li>
</ol>
<p>*注：对线性表操作的限制有很多，上述只介绍两种主流的限制，在数据结构中叫做<strong>栈</strong>和<strong>队列</strong>。</p>
<p>栈的概念比较抽象，举个栗子（<strong>对，就是板栗的栗子</strong>）。</p>
<p>一群人依次走进一个死胡同，宽度只够通行一个人。如果他们要出来，只能依次退出来。最后进去的人最先出来，在外面的人也只看的见最后进去的人是谁。这里，进去一个人叫做插入结点，出来一个人叫做删除结点。看的见最后进去的人，叫访问结点。</p>
<p>总结：栈有先进后出的特性，简称FILO（First in Last Out）。只能在线性表的一端插入和删除结点。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>栈是操作受限制的线性表，根据不同的存储结构可分成顺序栈和链式栈。<br>在顺序栈中，可以将顺序表的有效长度作为栈顶指针，在顺序表的末尾删除和插入节点。<br>在链式栈中，可以将链表的头结点作为栈顶指针，入栈采用头插法。</p>
<h2 id="定义结构"><a href="#定义结构" class="headerlink" title="定义结构"></a>定义结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INIT_SIZE 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTINCREMENT 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> StackType; <span class="comment">//存储单元类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">stackNode</span> &#123;</span><br><span class="line">	StackType *elem; <span class="comment">//存储空间基地址</span></span><br><span class="line">	<span class="type">int</span> length; <span class="comment">//当前长度</span></span><br><span class="line">	<span class="type">int</span> listsize; <span class="comment">//当前分配的存储容量（以sizeof(ElemType)为单位）</span></span><br><span class="line">&#125;Stack;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里定义的实际上是顺序表的结构，所以实现的也就是顺序栈。只是操作方法比顺序表的操作少很多。</p>
</blockquote>
<h2 id="定义操作"><a href="#定义操作" class="headerlink" title="定义操作"></a>定义操作</h2><h3 id="初始化栈"><a href="#初始化栈" class="headerlink" title="初始化栈"></a>初始化栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">initStack</span><span class="params">(Stack&amp; stack)</span> </span>&#123;</span><br><span class="line">	stack.elem = (StackType *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(StackType) * LIST_INIT_SIZE);</span><br><span class="line">	<span class="keyword">if</span> (!stack.elem)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//内存分配失败，存储空间不够</span></span><br><span class="line">	stack.length = <span class="number">0</span>;</span><br><span class="line">	stack.listsize = LIST_INIT_SIZE;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>给栈的基地址分配一段连续的存储单元，并标记栈的长度为0。初始化成功返回1，初始化失败返回0。</p>
</blockquote>
<h3 id="判断栈是否为空"><a href="#判断栈是否为空" class="headerlink" title="判断栈是否为空"></a>判断栈是否为空</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isEmptyStack</span><span class="params">(Stack stack)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> stack.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>栈为空，返回0，不为空返回非0。</p>
</blockquote>
<h3 id="访问栈顶元素"><a href="#访问栈顶元素" class="headerlink" title="访问栈顶元素"></a>访问栈顶元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">(Stack stack, StackType&amp; elem)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (stack.length == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	elem = stack.elem[stack.length - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>取出栈顶元素，传值给形参elem，但不删除栈顶元素。由于采用的是引用的方式，因此形参值的改变可以传给实参。如果栈为空，返回0，栈非空，返回1。</p>
</blockquote>
<h3 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">(Stack&amp; stack, StackType&amp; elem)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (stack.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		elem = stack.elem[--stack.length];</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>取出并删除栈顶元素，传值给形参elem。由于采用的是引用的方式，因此形参值的改变可以传给实参。如果栈为空，返回0，栈非空，返回1。</p>
</blockquote>
<h3 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">push</span><span class="params">(Stack&amp; stack, StackType data)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (stack.length == stack.listsize) &#123; <span class="comment">//顺序表的存储单元已经存满</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表的存储单元已满，继续分配新的存储单元。&quot;</span>);</span><br><span class="line">		StackType* newBase = (StackType*) <span class="built_in">realloc</span>(stack.elem,</span><br><span class="line">				(stack.listsize + LISTINCREMENT) * <span class="built_in">sizeof</span>(StackType)); <span class="comment">//继续分配存储单元</span></span><br><span class="line">		<span class="keyword">if</span> (!newBase) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;分配内存单元失败&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		stack.elem = newBase;</span><br><span class="line">		stack.listsize += LISTINCREMENT;</span><br><span class="line">	&#125;</span><br><span class="line">	stack.elem[stack.length] = data;</span><br><span class="line">	stack.length++;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在栈顶插入元素。若，当前栈已满，继续分配内存单元再插入。返回1表示入栈成功，返回0表示入栈失败。</p>
</blockquote>
<p>最后附上头文件的定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * stack.h</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Created on: 2016年9月26日</span></span><br><span class="line"><span class="comment"> *      Author: flueky</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> STACK_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INIT_SIZE 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTINCREMENT 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> StackType; <span class="comment">//存储单元类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">stackNode</span> &#123;</span><br><span class="line">	StackType *elem; <span class="comment">//存储空间基地址</span></span><br><span class="line">	<span class="type">int</span> length; <span class="comment">//当前长度</span></span><br><span class="line">	<span class="type">int</span> listsize; <span class="comment">//当前分配的存储容量（以sizeof(ElemType)为单位）</span></span><br><span class="line">&#125;Stack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">initStack</span><span class="params">(Stack&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isEmptyStack</span><span class="params">(Stack)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">(Stack,StackType&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">push</span><span class="params">(Stack&amp;,StackType)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">(Stack&amp;,StackType&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* STACK_H_ */</span></span></span><br></pre></td></tr></table></figure>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/test/page/3/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/test/">1</a><span class="space">&hellip;</span><a class="page-number" href="/test/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/test/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/test/page/7/">7</a><a class="extend next" rel="next" href="/test/page/5/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2016 - 2024 By flueky</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/test/js/utils.js?version=1.9.1"></script><script src="/test/js/fancybox.js?version=1.9.1"></script><script src="/test/js/sidebar.js?version=1.9.1"></script><script src="/test/js/copy.js?version=1.9.1"></script><script src="/test/js/fireworks.js?version=1.9.1"></script><script src="/test/js/transition.js?version=1.9.1"></script><script src="/test/js/scroll.js?version=1.9.1"></script><script src="/test/js/head.js?version=1.9.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>