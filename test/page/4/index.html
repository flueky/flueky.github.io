<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="小飞哥的个人博客主页"><meta name="keywords" content=""><meta name="author" content="flueky"><meta name="copyright" content="flueky"><title>Android 程序猿秘籍 | Flueky 技术小站</title><link rel="shortcut icon" href="/test/melody-favicon.ico"><link rel="stylesheet" href="/test/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/test/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/test/img/avatar.png"></div><div class="author-info__name text-center">flueky</div><div class="author-info__description text-center">小飞哥的个人博客主页</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/test/archives"><span class="pull-left">Articles</span><span class="pull-right">56</span></a><a class="author-info-articles__tags article-meta" href="/test/tags"><span class="pull-left">Tags</span><span class="pull-right">20</span></a><a class="author-info-articles__categories article-meta" href="/test/categories"><span class="pull-left">Categories</span><span class="pull-right">11</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/test/">Flueky 技术小站</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right"></span></div><div id="site-info"><div id="site-title">Flueky 技术小站</div><div id="site-sub-title">Android 程序猿秘籍</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/test/227/">数据结构（五）——二叉树（C语言实现）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-10-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/C-C/">C/C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/test/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a></span><div class="content"><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>之前四篇博客分别介绍了线性结构中的[顺序表](&#x2F;222)、[链表](&#x2F;223)、[栈](&#x2F;225)、[队列](&#x2F;226)。从难度来讲，顺序表到链表是递增的。从实现来讲，栈和队列基于顺序表和链表（<strong>之前栈采用了顺序表的存储结构，队列采用了链表的存储结构</strong>）。此次介绍的二叉树虽是非线性结构的树形结构分支，但在其各个结点遍历的实现上，使用到了栈和队列的特性。</p>
<p><strong>二叉树</strong>是一种特殊的线性结构，每个结点最多只有两个分支，称左孩子结点和右孩子结点。更多关于二叉树的特性，自行查阅资料。接下来只详细的介绍创建二叉树以及二叉树的遍历。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="定义结构"><a href="#定义结构" class="headerlink" title="定义结构"></a>定义结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> TreeType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BitNode</span> &#123;</span><br><span class="line">	TreeType key;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BitNode</span> *left;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BitNode</span> *right;</span><br><span class="line">&#125; BitTree;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>二叉树的结构和双向链表的结构一致，只是双向链表的两个指针构成线性结构，二叉树的两个指针构成非线性结构。</p>
</blockquote>
<h2 id="定义操作"><a href="#定义操作" class="headerlink" title="定义操作"></a>定义操作</h2><h3 id="构造空二叉树"><a href="#构造空二叉树" class="headerlink" title="构造空二叉树"></a>构造空二叉树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造空二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initBitTree</span><span class="params">(BitTree&amp; root)</span> </span>&#123;</span><br><span class="line">	root.left = <span class="literal">NULL</span>;</span><br><span class="line">	root.right = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将根结点的左右两个指针置空。</p>
</blockquote>
<h3 id="创建二叉树"><a href="#创建二叉树" class="headerlink" title="创建二叉树"></a>创建二叉树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建二叉树(按照前序遍历方式构建二叉树)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createBitTree</span><span class="params">(BitTree** parent)</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span> key = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">if</span> (key == <span class="string">&#x27;#&#x27;</span>) &#123; <span class="comment">//输入#表示该节点是叶子节点</span></span><br><span class="line">		*parent = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		*parent = (BitTree*) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BitTree));</span><br><span class="line">		<span class="keyword">if</span> (*parent == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">9</span>);</span><br><span class="line">		(*parent)-&gt;key = key;</span><br><span class="line">		<span class="built_in">createBitTree</span>(&amp;((*parent)-&gt;left));</span><br><span class="line">		<span class="built_in">createBitTree</span>(&amp;((*parent)-&gt;right));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>先序遍历的方式构建二叉树，输入#号表示当前结点的左孩子结点或右孩子结点为空。</p>
</blockquote>
<h3 id="递归先序遍历"><a href="#递归先序遍历" class="headerlink" title="递归先序遍历"></a>递归先序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归先序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrderTraverse</span><span class="params">(BitTree* parent)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (parent != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">visit</span>(*parent);</span><br><span class="line">		<span class="built_in">preOrderTraverse</span>(parent-&gt;left);<span class="comment">//遍历左子树</span></span><br><span class="line">		<span class="built_in">preOrderTraverse</span>(parent-&gt;right);<span class="comment">//遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>先访问根结点，再依次递归访问左子树和右子树</p>
</blockquote>
<h3 id="递归中序遍历"><a href="#递归中序遍历" class="headerlink" title="递归中序遍历"></a>递归中序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归中序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderTraverse</span><span class="params">(BitTree* parent)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (parent != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">inOrderTraverse</span>(parent-&gt;left);<span class="comment">//遍历左子树</span></span><br><span class="line">		<span class="built_in">visit</span>(*parent);</span><br><span class="line">		<span class="built_in">inOrderTraverse</span>(parent-&gt;right);<span class="comment">//遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>先递归遍历左子树，再访问根节点，最后递归访问右子树。</p>
</blockquote>
<h3 id="递归后序遍历"><a href="#递归后序遍历" class="headerlink" title="递归后序遍历"></a>递归后序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归后序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrderTraverse</span><span class="params">(BitTree* parent)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (parent != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">postOrderTraverse</span>(parent-&gt;left);<span class="comment">//遍历左子树</span></span><br><span class="line">		<span class="built_in">postOrderTraverse</span>(parent-&gt;right);<span class="comment">//遍历右子树</span></span><br><span class="line">		<span class="built_in">visit</span>(*parent);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>先依次递归访问左子树和右子树，最后访问根结点。</p>
</blockquote>
<p>*<strong>三序遍历的递归方式简单的介绍到这里，三序遍历的非递归方式一个比一个难，这是本人自行思考写出的算法，若说阅读了参考资料那也是很久之前的事情。因此觉得，这三段代码还是很有阅读价值。</strong></p>
<h3 id="非递归先序遍历"><a href="#非递归先序遍历" class="headerlink" title="非递归先序遍历"></a>非递归先序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非递归先序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrderTraverseNormal</span><span class="params">(BitTree* parent)</span> </span>&#123;</span><br><span class="line">	Stack stack;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">initStack</span>(stack) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (parent == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">push</span>(stack, *parent);</span><br><span class="line">	BitTree topNode;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">pop</span>(stack, topNode)) &#123; <span class="comment">//取栈顶元素，访问并出栈</span></span><br><span class="line">		<span class="built_in">visit</span> (node); <span class="comment">//访问栈顶元素</span></span><br><span class="line">		<span class="keyword">if</span> (topNode.right != <span class="literal">NULL</span>) &#123; <span class="comment">//存在右结点，则先将右结点入栈。因为左结点先遍历</span></span><br><span class="line">			<span class="built_in">push</span>(stack, *(topNode.right));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (topNode.left != <span class="literal">NULL</span>) &#123; <span class="comment">//存在左结点，左结点入栈</span></span><br><span class="line">			<span class="built_in">push</span>(stack, *(topNode.left));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>非递归遍历的重点是手动构造递归栈。首先将根结点入栈，然后在while循环中，先将栈顶结点出栈，并依次将该结点的右孩子结点和左孩子结点入栈（如果存在），知道栈为空pop函数返回0 结束循环。</p>
</blockquote>
<h3 id="非递归中序遍历"><a href="#非递归中序遍历" class="headerlink" title="非递归中序遍历"></a>非递归中序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非递归中序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderTraverseNormal</span><span class="params">(BitTree* parent)</span> </span>&#123;</span><br><span class="line">	Stack stack;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">initStack</span>(stack) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (parent == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">push</span>(stack, *parent);</span><br><span class="line">	BitTree topNode;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">top</span>(stack, topNode)) &#123; <span class="comment">//取栈顶结点</span></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 首先，一直遍历到最左边的结点</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">while</span> (topNode.left != <span class="literal">NULL</span>) &#123; <span class="comment">//左孩子结点不为空，入栈</span></span><br><span class="line">			<span class="built_in">push</span>(stack, *(topNode.left));<span class="comment">//左孩子结点入栈</span></span><br><span class="line">			topNode = *(topNode.left);<span class="comment">//看下一个左孩子结点</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 其次，判断其是否存在右孩子结点。</span></span><br><span class="line"><span class="comment">		 * 不存在右孩子结点，直接将该结点出栈</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (flag &amp;&amp; topNode.right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="built_in">pop</span>(stack, topNode);<span class="comment">//出栈</span></span><br><span class="line">			<span class="built_in">visit</span>(topNode);</span><br><span class="line">			flag = <span class="built_in">top</span>(stack, topNode);<span class="comment">//取栈顶结点，继续判断</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 存在右孩子结点，当前结点出栈，并将右孩子结点入栈</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">pop</span>(stack, topNode)) &#123;</span><br><span class="line">			<span class="built_in">visit</span>(topNode);</span><br><span class="line">			<span class="built_in">push</span>(stack, *(topNode.right));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>先将根结点入栈，然后根据根结点一直寻找到该左子树的最左边结点，访问该结点。如果该结点不存在右子树，直接将该结点出栈，并一直出栈到栈顶的结点存在右子树。此时将栈顶结点出栈，并将该结点的右孩子结点入栈，并寻找到该结点右子树的最左边结点。</p>
</blockquote>
<h3 id="非递归后序遍历"><a href="#非递归后序遍历" class="headerlink" title="非递归后序遍历"></a>非递归后序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非递归后序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrderTraverseNormal</span><span class="params">(BitTree* parent)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 声明两个栈，遍历树的管理栈和备用栈</span></span><br><span class="line"><span class="comment">	 * 备用栈的作用：部分结点存在两次访问的，备用栈是记录第一次访问，然后入栈。</span></span><br><span class="line"><span class="comment">	 * 也可以在结点中添加一个标签记录访问次数，备用栈的设计是为了避免修改结点</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Stack stack, backup;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">initStack</span>(stack) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">initStack</span>(backup) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (parent == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">push</span>(stack, *parent);</span><br><span class="line">	BitTree topNode; <span class="comment">//记录当前栈顶结点</span></span><br><span class="line">	BitTree backupNode; <span class="comment">//记录备用栈的栈顶结点</span></span><br><span class="line">	BitTree lastNode; <span class="comment">//上次访问的结点</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">top</span>(stack, topNode)) &#123; <span class="comment">//取栈顶结点</span></span><br><span class="line">		<span class="type">int</span> flag = <span class="built_in">top</span>(backup, backupNode); <span class="comment">//备用栈的栈顶元素,返回0表示备用栈为空。</span></span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">0</span> || <span class="built_in">compareTreeNode</span>(topNode, backupNode) == <span class="number">0</span>) &#123; <span class="comment">//该结点是第一次访问</span></span><br><span class="line">			<span class="keyword">if</span> (topNode.left != <span class="literal">NULL</span></span><br><span class="line">					&amp;&amp; <span class="built_in">compareTreeNode</span>(*(topNode.left), lastNode) == <span class="number">0</span>) &#123; <span class="comment">//左孩子结点不为空，且上次访问的不是左孩子结点</span></span><br><span class="line">				<span class="built_in">push</span>(stack, *(topNode.left)); <span class="comment">//左孩子结点入栈</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">push</span>(backup, topNode);</span><br><span class="line">			<span class="keyword">if</span> (topNode.right != <span class="literal">NULL</span></span><br><span class="line">					&amp;&amp; <span class="built_in">compareTreeNode</span>(*(topNode.right), lastNode) == <span class="number">0</span>) &#123; <span class="comment">//右孩子结点不为空，且上次访问的不是右孩子结点</span></span><br><span class="line">				<span class="built_in">push</span>(stack, *(topNode.right)); <span class="comment">//右孩子结点入栈</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">//该节结点是第二次访问，直接出栈</span></span><br><span class="line">			<span class="built_in">pop</span>(backup, backupNode); <span class="comment">//备用栈栈顶元素出栈</span></span><br><span class="line">			<span class="built_in">pop</span>(stack, topNode); <span class="comment">//当前栈栈顶元素出栈</span></span><br><span class="line">			<span class="built_in">visit</span>(topNode); <span class="comment">//访问刚出栈的结点</span></span><br><span class="line">			lastNode = topNode; <span class="comment">//记录刚刚访问的结点</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>考虑到后续遍历的特殊性质，根结点会在左孩子结点和右孩子结点出栈时访问两次。多数资料上的实现方式都是通过在每个结点中添加一个标志记录根节点的访问次数。为了维护之前定义好的结构体的完整性。用一个备用栈，完美的解决问题。</p>
</blockquote>
<blockquote>
<p>取递归栈中的栈顶元素和备用栈中的栈顶元素（如果存在）对比，如果相同，就是第二次遍历到该结点。分别将递归栈和备用栈中的栈顶元素出栈，访问并记录当前出栈的结点。如果不相同，就是第一次访问该结点，此时需要考虑当前递归栈中栈顶结点是否存在左子树或右子树以及上次出栈的结点是否是该结点的左孩子结点或右孩子结点。<br>当该结点不存在左子树或上次出栈的结点是该结点的左孩子结点，则标记当前递归栈中的栈顶结点已经访问过一次，将该结点添加到备用栈中。</p>
</blockquote>
<blockquote>
<p>说了这么多，有点绕。经过长时间的思考以及两次优化之后的成果。越是难懂的算法不一定就是最高级的算法，此处 ，不对我的代码做任何评价。</p>
</blockquote>
<h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 层次遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrderTraverse</span><span class="params">(BitTree* parent)</span> </span>&#123;</span><br><span class="line">	Queue queue = <span class="built_in">createQueue</span>();<span class="comment">//创建队列</span></span><br><span class="line">	<span class="built_in">enterQueue</span>(queue, *parent);<span class="comment">//根结点入队</span></span><br><span class="line">	BitTree node;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">exitQueue</span>(queue, node)) &#123;<span class="comment">//队列中结点出队，队列为空，返回0，while循环结束</span></span><br><span class="line">		<span class="built_in">visit</span>(child);<span class="comment">//访问队列中第一个结点</span></span><br><span class="line">		<span class="keyword">if</span> (node.left != <span class="number">0</span>)<span class="comment">//判断是否存在左孩子结点，将左孩子结点入队</span></span><br><span class="line">			<span class="built_in">enterQueue</span>(queue, *node.left);</span><br><span class="line">		<span class="keyword">if</span> (node.right != <span class="number">0</span>)<span class="comment">//判断是否存在右孩子结点，将右孩子结点入队</span></span><br><span class="line">			<span class="built_in">enterQueue</span>(queue, *node.right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>看完前面三个非递归的遍历算法，也许都晕了。层次遍历，没有递归或非递归而言，自顶向下、从左到右访问二叉树中所有的结点。先访问的结点子树上的全部结点一定比后访问结点子树上的全部结点先访问，所以层次遍历用到了队的特性。</p>
</blockquote>
<h3 id="访问结点"><a href="#访问结点" class="headerlink" title="访问结点"></a>访问结点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(BitTree node)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, node.key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这只是模拟访问结点的操作，可根据需要自定定义该函数的功能。</p>
</blockquote>
<p>上述代码中用到的栈和队列中的函数，都是复用了之前博客中介绍的栈和队列的操作函数。只是修改下每个元素的结点类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> STACK_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tree.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INIT_SIZE 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTINCREMENT 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> BitTree StackType; <span class="comment">//栈中每个元素的结点类型是二叉树</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">stackNode</span> &#123;</span><br><span class="line">	StackType *elem; <span class="comment">//存储空间基地址</span></span><br><span class="line">	<span class="type">int</span> length; <span class="comment">//当前长度</span></span><br><span class="line">	<span class="type">int</span> listsize; <span class="comment">//当前分配的存储容量（以sizeof(ElemType)为单位）</span></span><br><span class="line">&#125;Stack;</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> QUEUE_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUEUE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tree.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> BitTree QueueType;<span class="comment">//队列中每个元素的结点类型是二叉树</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LinkQueue</span> &#123;</span><br><span class="line">	QueueType key;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LinkQueue</span> *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">queueNode</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LinkQueue</span> *head; <span class="comment">//队列的头指针</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LinkQueue</span> *end; <span class="comment">//队列的尾指针</span></span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>最后，附上头文件的定义，部分方法未实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * tree.h</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Created on: 2016年9月25日</span></span><br><span class="line"><span class="comment"> *      Author: flueky</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stack.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;queue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TREE_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TREE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> TreeType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BitNode</span> &#123;</span><br><span class="line">	TreeType key;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BitNode</span> *left;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BitNode</span> *right;</span><br><span class="line">&#125; BitTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造空二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initBitTree</span><span class="params">(BitTree&amp;)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 销毁二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destoryBitTree</span><span class="params">(BitTree&amp;)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createBitTree</span><span class="params">(BitTree**)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将二叉树清为空树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearBitTree</span><span class="params">(BitTree&amp;)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归先序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrderTraverse</span><span class="params">(BitTree*)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非递归先序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrderTraverseNormal</span><span class="params">(BitTree*)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归中序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderTraverse</span><span class="params">(BitTree*)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非递归中序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderTraverseNormal</span><span class="params">(BitTree*)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归后序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrderTraverse</span><span class="params">(BitTree*)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非递归后序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrderTraverseNormal</span><span class="params">(BitTree*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 层次遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrderTraverse</span><span class="params">(BitTree*)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 比较两个结点，相同返回1，不同返回0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compareTreeNode</span><span class="params">(BitTree, BitTree)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(BitTree)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TREE_H_ */</span></span></span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/test/226/">数据结构（四）——队列（C语言实现）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-10-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/C-C/">C/C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/test/tags/%E9%98%9F%E5%88%97/">队列</a></span><div class="content"><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>在[栈](&#x2F;225)中提到，队列是操作受限制的特殊的线性表。<br>在队列的一端只能插入元素，这一端叫做队尾。<br>在队列的另一端只能删除元素，这一端叫做队首。</p>
<p>同样举个栗子。<br>在食堂排队打饭，跑的快的同学排在队列的前面，最先打到饭菜。后续到的同学只能依次排列在队尾。买到饭菜的同学离开队列叫做出队，进入队列等候叫做入队。食堂阿姨给队列中第一个同学打饭叫做访问队首元素。</p>
<p>总结：队列有先进先出的特性，FIFO（First In First Out）。每次只能在线性表的两端操作元素。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>考虑到每次出队和入队都要移动队首和队尾指针。若采用顺序存储，将会有可能造成顺序表前段部分存储单元的浪费。虽说可以采用循环队列的方式复用存储单元，若遇到队列满的情况，将队列扩容比较麻烦。因此建议用链表的方式实现队列。</p>
<h2 id="定义结构"><a href="#定义结构" class="headerlink" title="定义结构"></a>定义结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QueueType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LinkQueue</span>&#123;</span><br><span class="line">	QueueType key;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LinkQueue</span> *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">queueNode</span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LinkQueue</span> *head;<span class="comment">//队列的头指针</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LinkQueue</span> *end;<span class="comment">//队列的尾指针</span></span><br><span class="line">&#125;Queue;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里定义了连个结构体，链表和队列。队列中只保存两个指针——<strong>队首</strong>、<strong>队尾</strong>。后面的入队、出队的操作，只需要操作这两个指针就好。</p>
</blockquote>
<h2 id="定义操作"><a href="#定义操作" class="headerlink" title="定义操作"></a>定义操作</h2><h3 id="创建队列"><a href="#创建队列" class="headerlink" title="创建队列"></a>创建队列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Queue <span class="title">createQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Queue queue;</span><br><span class="line">	queue.head = <span class="number">0</span>;</span><br><span class="line">	queue.end = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>采用静态方式分配队列存储单元。初始化队首和队尾指针。</p>
</blockquote>
<h3 id="判断队列是否为空"><a href="#判断队列是否为空" class="headerlink" title="判断队列是否为空"></a>判断队列是否为空</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断队列是否是空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isEmpty</span><span class="params">(Queue queue)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (queue.head == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>队首指针指向空结点，表示队列为空。</p>
</blockquote>
<h3 id="访问队首元素"><a href="#访问队首元素" class="headerlink" title="访问队首元素"></a>访问队首元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取队列第一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getFirst</span><span class="params">(Queue queue, QueueType&amp; elem)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (queue.head == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	elem = queue.head-&gt;key;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>队首指针可作为链表的头结点。通过头结点访问链表的第一个结点。</p>
</blockquote>
<h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 退出队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exitQueue</span><span class="params">(Queue&amp; queue, QueueType&amp; val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">isEmpty</span>(queue) == <span class="number">0</span>) <span class="comment">//空队列</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LinkQueue</span>* node = queue.head;</span><br><span class="line">	queue.head = node-&gt;next;</span><br><span class="line">	node-&gt;next = <span class="number">0</span>;</span><br><span class="line">	val = node-&gt;key;</span><br><span class="line">	<span class="built_in">free</span>(node);</span><br><span class="line">	<span class="keyword">if</span> (queue.head == <span class="number">0</span>)</span><br><span class="line">		queue.end = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过队首指针，删除队列第一个结点。如果删除后队列为空，将队尾指针置空，否则队尾指针仍然指向最后一个元素。队列为空，删除失败，返回0 。删除成功返回1。</p>
</blockquote>
<h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进入队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">enterQueue</span><span class="params">(Queue&amp; queue, QueueType key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LinkQueue</span>* node = (<span class="keyword">struct</span> LinkQueue*) <span class="built_in">malloc</span>(</span><br><span class="line">			<span class="built_in">sizeof</span>(<span class="keyword">struct</span> LinkQueue));</span><br><span class="line">	<span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	node-&gt;key = key;</span><br><span class="line">	node-&gt;next = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (queue.end == <span class="number">0</span>) &#123;</span><br><span class="line">		queue.end = node;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;<span class="comment">//修改队尾指针</span></span><br><span class="line">		queue.end-&gt;next = node;</span><br><span class="line">		queue.end = node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (queue.head == <span class="number">0</span>) &#123;</span><br><span class="line">		queue.head = node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>队列为空时，队首和队尾指针指向同一个结点就好。队列不为空时，修改队尾指针指向新插入的结点。入队成功返回1，入队失败返回0。</p>
</blockquote>
<p>最后附上头文件的定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * queue.h</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Created on: 2016年9月30日</span></span><br><span class="line"><span class="comment"> *      Author: flueky</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> QUEUE_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUEUE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QueueType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LinkQueue</span> &#123;</span><br><span class="line">	QueueType key;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LinkQueue</span> *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">queueNode</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LinkQueue</span> *head; <span class="comment">//队列的头指针</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LinkQueue</span> *end; <span class="comment">//队列的尾指针</span></span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Queue <span class="title">createQueue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断队列是否是空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isEmpty</span><span class="params">(Queue)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取队列第一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getFirst</span><span class="params">(Queue, QueueType&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进入队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">enterQueue</span><span class="params">(Queue&amp;, QueueType)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 退出队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exitQueue</span><span class="params">(Queue&amp;, QueueType&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearQueue</span><span class="params">(Queue)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* QUEUE_H_ */</span></span></span><br></pre></td></tr></table></figure>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/test/225/">数据结构（三）——栈（C语言实现）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-10-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/C-C/">C/C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/test/tags/%E6%A0%88/">栈</a></span><div class="content"><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>在线性表中，根据存储结构可分为：[顺序表](&#x2F;222&#x2F;) 和 [链表](&#x2F;223)。顺序表和链表可以访问任意位置结点，在任意位置插入和删除结点。倘若对上述操作加以限制，如：</p>
<ol>
<li>   在线性表的一端插入、删除、访问结点。</li>
<li>   在线性表的一端插入结点、另一端删除、访问结点。</li>
</ol>
<p>*注：对线性表操作的限制有很多，上述只介绍两种主流的限制，在数据结构中叫做<strong>栈</strong>和<strong>队列</strong>。</p>
<p>栈的概念比较抽象，举个栗子（<strong>对，就是板栗的栗子</strong>）。</p>
<p>一群人依次走进一个死胡同，宽度只够通行一个人。如果他们要出来，只能依次退出来。最后进去的人最先出来，在外面的人也只看的见最后进去的人是谁。这里，进去一个人叫做插入结点，出来一个人叫做删除结点。看的见最后进去的人，叫访问结点。</p>
<p>总结：栈有先进后出的特性，简称FILO（First in Last Out）。只能在线性表的一端插入和删除结点。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>栈是操作受限制的线性表，根据不同的存储结构可分成顺序栈和链式栈。<br>在顺序栈中，可以将顺序表的有效长度作为栈顶指针，在顺序表的末尾删除和插入节点。<br>在链式栈中，可以将链表的头结点作为栈顶指针，入栈采用头插法。</p>
<h2 id="定义结构"><a href="#定义结构" class="headerlink" title="定义结构"></a>定义结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INIT_SIZE 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTINCREMENT 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> StackType; <span class="comment">//存储单元类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">stackNode</span> &#123;</span><br><span class="line">	StackType *elem; <span class="comment">//存储空间基地址</span></span><br><span class="line">	<span class="type">int</span> length; <span class="comment">//当前长度</span></span><br><span class="line">	<span class="type">int</span> listsize; <span class="comment">//当前分配的存储容量（以sizeof(ElemType)为单位）</span></span><br><span class="line">&#125;Stack;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里定义的实际上是顺序表的结构，所以实现的也就是顺序栈。只是操作方法比顺序表的操作少很多。</p>
</blockquote>
<h2 id="定义操作"><a href="#定义操作" class="headerlink" title="定义操作"></a>定义操作</h2><h3 id="初始化栈"><a href="#初始化栈" class="headerlink" title="初始化栈"></a>初始化栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">initStack</span><span class="params">(Stack&amp; stack)</span> </span>&#123;</span><br><span class="line">	stack.elem = (StackType *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(StackType) * LIST_INIT_SIZE);</span><br><span class="line">	<span class="keyword">if</span> (!stack.elem)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//内存分配失败，存储空间不够</span></span><br><span class="line">	stack.length = <span class="number">0</span>;</span><br><span class="line">	stack.listsize = LIST_INIT_SIZE;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>给栈的基地址分配一段连续的存储单元，并标记栈的长度为0。初始化成功返回1，初始化失败返回0。</p>
</blockquote>
<h3 id="判断栈是否为空"><a href="#判断栈是否为空" class="headerlink" title="判断栈是否为空"></a>判断栈是否为空</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isEmptyStack</span><span class="params">(Stack stack)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> stack.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>栈为空，返回0，不为空返回非0。</p>
</blockquote>
<h3 id="访问栈顶元素"><a href="#访问栈顶元素" class="headerlink" title="访问栈顶元素"></a>访问栈顶元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">(Stack stack, StackType&amp; elem)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (stack.length == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	elem = stack.elem[stack.length - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>取出栈顶元素，传值给形参elem，但不删除栈顶元素。由于采用的是引用的方式，因此形参值的改变可以传给实参。如果栈为空，返回0，栈非空，返回1。</p>
</blockquote>
<h3 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">(Stack&amp; stack, StackType&amp; elem)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (stack.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		elem = stack.elem[--stack.length];</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>取出并删除栈顶元素，传值给形参elem。由于采用的是引用的方式，因此形参值的改变可以传给实参。如果栈为空，返回0，栈非空，返回1。</p>
</blockquote>
<h3 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">push</span><span class="params">(Stack&amp; stack, StackType data)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (stack.length == stack.listsize) &#123; <span class="comment">//顺序表的存储单元已经存满</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表的存储单元已满，继续分配新的存储单元。&quot;</span>);</span><br><span class="line">		StackType* newBase = (StackType*) <span class="built_in">realloc</span>(stack.elem,</span><br><span class="line">				(stack.listsize + LISTINCREMENT) * <span class="built_in">sizeof</span>(StackType)); <span class="comment">//继续分配存储单元</span></span><br><span class="line">		<span class="keyword">if</span> (!newBase) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;分配内存单元失败&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		stack.elem = newBase;</span><br><span class="line">		stack.listsize += LISTINCREMENT;</span><br><span class="line">	&#125;</span><br><span class="line">	stack.elem[stack.length] = data;</span><br><span class="line">	stack.length++;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在栈顶插入元素。若，当前栈已满，继续分配内存单元再插入。返回1表示入栈成功，返回0表示入栈失败。</p>
</blockquote>
<p>最后附上头文件的定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * stack.h</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Created on: 2016年9月26日</span></span><br><span class="line"><span class="comment"> *      Author: flueky</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> STACK_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INIT_SIZE 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTINCREMENT 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> StackType; <span class="comment">//存储单元类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">stackNode</span> &#123;</span><br><span class="line">	StackType *elem; <span class="comment">//存储空间基地址</span></span><br><span class="line">	<span class="type">int</span> length; <span class="comment">//当前长度</span></span><br><span class="line">	<span class="type">int</span> listsize; <span class="comment">//当前分配的存储容量（以sizeof(ElemType)为单位）</span></span><br><span class="line">&#125;Stack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">initStack</span><span class="params">(Stack&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isEmptyStack</span><span class="params">(Stack)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">(Stack,StackType&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">push</span><span class="params">(Stack&amp;,StackType)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">(Stack&amp;,StackType&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* STACK_H_ */</span></span></span><br></pre></td></tr></table></figure>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/test/224/">Java多线程示例——模拟银行柜台处理业务</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-10-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/Java/">Java</a></span><div class="content"><p>前不久看到一个题目<a target="_blank" rel="noopener" href="http://ask.csdn.net/questions/336334">模拟银行柜台处理业务</a>觉得很有意思，模拟银行柜台处理业务，考察的多线程编程，以及多线程间通信。由于以前没有系统学习过Java，工作中也是根据实际需要，去选择Java的一个部分再次学习。所以多线程编程一直是自己的软肋。甚至分不清实现Runnable接口和继承Thread类的区别。顺便问一下有人知道实现多线程编程的第三种方式么？在处理这个问题之前，先看了一遍《疯狂Java讲义》（这本书用来Java编程入门足以）中关于多线程的章节，心中关于题目中实现线程间通信也有了几种不同的方案，这里根据实际需要选择最容易实现的一种。</p></div><a class="more" href="/test/224/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/test/223/">数据结构（二）——链表（C语言实现）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-09-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/C-C/">C/C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/test/tags/%E9%93%BE%E8%A1%A8/">链表</a></span><div class="content"><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>相对于顺序表而言，“勤拿少取”这是对链表最形象的描述。意指，它需要一个结点，就在内存中分配一块内存单元。比顺序表不足的是，链表的每个结点中，需要一个存储单元保存指向下一个结点的地址。</p>
<p>链表的访问需要从第一个结点（或称头结点）开始寻找，（顺序表可以根据下标直接访问）。链表的插入和删除只需对指定位置的结点操作即可。</p>
<p>常见的链表，根据指向下个链表的指针可分为<strong>单向链表</strong>，<strong>双向链表</strong>。根据第一个结点是否存储元素可分为<strong>带头结点的链表</strong>和<strong>不带头结点的链表</strong>。再根据末尾结点next指针的指向可分为<strong>循环链表</strong>和<strong>非循环链表</strong>。</p>
<p>*<strong>下面程序以单向带头结点的非循环链表为例</strong>。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="定义结构"><a href="#定义结构" class="headerlink" title="定义结构"></a>定义结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> LinkType; <span class="comment">//存储单元类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">linkNode</span> &#123;</span></span><br><span class="line">	LinkType key; <span class="comment">//结点的key值</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">linkNode</span> *<span class="title">next</span>;</span> <span class="comment">//指向下一个结点</span></span><br><span class="line">&#125; LNode, *LinkList;<span class="comment">//LNode 是普通类型，LinkList是指针类型</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>定义LinkType类型，使该链表结构适合更多数据类型。每个链表的结点，包含一个值域key和一个指针域next。这里声明两种类型<code>LNode</code>和<code>LinkList</code>。以下两行代码是等价的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LNode* node = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">LinkList node = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br></pre></td></tr></table></figure>

<h2 id="定义操作"><a href="#定义操作" class="headerlink" title="定义操作"></a>定义操作</h2><h3 id="创建头结点"><a href="#创建头结点" class="headerlink" title="创建头结点"></a>创建头结点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建头结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">LinkList <span class="title function_">createHead_link</span><span class="params">()</span> &#123;</span><br><span class="line">	LinkList head = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里是动态分配一个内存单元存储头结点，也可以参照<a target="_blank" rel="noopener" href="http://blog.csdn.net/flueky/article/details/52711668">顺序表</a>中，使用<code>LNode head</code>，由系统分配内存。<a href="%5B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E9%A1%BA%E5%BA%8F%E8%A1%A8%EF%BC%88C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%EF%BC%89%5D(http://blog.csdn.net/flueky/article/details/52711668)">^footnote</a></p>
</blockquote>
<h3 id="插入结点"><a href="#插入结点" class="headerlink" title="插入结点"></a>插入结点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 头插法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertFirst_link</span><span class="params">(LinkList head, LinkType val)</span> &#123;</span><br><span class="line">	LinkList node = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	node-&gt;key = val;</span><br><span class="line">	node-&gt;next = head-&gt;next;</span><br><span class="line">	head-&gt;next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在带头结点的链表中，头插法表示每次将结点插入到头结点的后面。在不带头结点的链表中，将待插入的结点放在链表中第一个结点的前面，代替之成为第一个结点。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尾插法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertLast_link</span><span class="params">(LinkList head, LinkType val)</span> &#123;</span><br><span class="line">	LinkList temp = head;</span><br><span class="line">	<span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>) <span class="comment">//找到末尾结点</span></span><br><span class="line">		temp = temp-&gt;next;</span><br><span class="line">	LinkList node = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	node-&gt;key = val;</span><br><span class="line">	temp-&gt;next = node;</span><br><span class="line">	node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于尾插法而言，不区分带头结点和不带头结点的链表。只将待插入的结点插到链表的最后一个位置。因此需要先循环到链表的末尾。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定位置插入，position表示插入后的位置，0表示头结点后的第一个结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert_link</span><span class="params">(LinkList head, <span class="type">int</span> position, LinkType val)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (position &lt; <span class="number">0</span>) <span class="comment">//-1 从末尾添加，采用尾插法</span></span><br><span class="line">		insertLast_link(head, val);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (position == <span class="number">0</span>) <span class="comment">//从第一个结点插入，采用头插法</span></span><br><span class="line">		insertFirst_link(head, val);</span><br><span class="line">	<span class="keyword">else</span> &#123; <span class="comment">//</span></span><br><span class="line">		LinkList temp = head-&gt;next;</span><br><span class="line">		<span class="keyword">while</span> (temp != <span class="literal">NULL</span> &amp;&amp; --position &gt; <span class="number">0</span>) &#123; <span class="comment">//找到合适的位置结点</span></span><br><span class="line">			temp = temp-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		LinkList node = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">		node-&gt;key = val;</span><br><span class="line">		node-&gt;next = temp-&gt;next;</span><br><span class="line">		temp-&gt;next = node;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>先根据下标找到待插入的位置，然后插入结点。对比顺序表，先移动指定位置的后续结点，再插入新的结点。</p>
</blockquote>
<h3 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除节点（指定位置）,下标从0开始</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">removeNode_link</span><span class="params">(LinkList head, <span class="type">int</span> index, LinkType &amp;key)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;指定下标值不正确\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LinkList node = head;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!node-&gt;next || i &lt; index) &#123; <span class="comment">//寻找指定下标的节点，结束循环时，i==index</span></span><br><span class="line">		node = node-&gt;next;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (i == index) &#123; <span class="comment">//找到指定节点</span></span><br><span class="line">		LinkList temp = node-&gt;next; <span class="comment">//temp 是要被删除的节点</span></span><br><span class="line">		node-&gt;next = temp-&gt;next;</span><br><span class="line">		temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		key = temp-&gt;key;</span><br><span class="line">		<span class="built_in">free</span>(temp);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">//没找到</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;没找到指定下标的值&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>下标从0开始，表示头结点后的第一个结点。先找到待删除的结点，取出key值，再删除该结点。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除节点（指定节点）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">removeNode_link</span><span class="params">(LinkList head, LinkType val)</span> &#123;</span><br><span class="line">	LinkList node = head;</span><br><span class="line">	<span class="keyword">while</span> (!node-&gt;next) &#123;</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;next-&gt;key == val)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		node = node-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (node-&gt;next != <span class="literal">NULL</span>) &#123; <span class="comment">//找到要删除的节点</span></span><br><span class="line">		LinkList temp = node-&gt;next; <span class="comment">//temp 是要被删除的节点</span></span><br><span class="line">		node-&gt;next = temp-&gt;next;</span><br><span class="line">		temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="built_in">free</span>(temp);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;没找到要删除的节点\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>首先根据val值，找到待删除的结点，最后删除之。</p>
</blockquote>
<h3 id="销毁链表"><a href="#销毁链表" class="headerlink" title="销毁链表"></a>销毁链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 销毁链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destory_link</span><span class="params">(LinkList head)</span> &#123;</span><br><span class="line">	<span class="keyword">while</span> (head-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		LinkList node = head-&gt;next;</span><br><span class="line">		head-&gt;next = node-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(node);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>释放掉除头结点之外的所有结点占用的内存。</p>
</blockquote>
<p>最后附上，头文件的定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * linklist.h</span></span><br><span class="line"><span class="comment"> * 顺序表的链式存储结构</span></span><br><span class="line"><span class="comment"> *  Created on: 2016年8月30日</span></span><br><span class="line"><span class="comment"> *      Author: flueky</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LINKLIST_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LINKLIST_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> LinkType; <span class="comment">//存储单元类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">linkNode</span> &#123;</span></span><br><span class="line">	LinkType key; <span class="comment">//节点的key值</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">linkNode</span> *<span class="title">next</span>;</span> <span class="comment">//指向下一个节点</span></span><br><span class="line">&#125; LNode, *LinkList;<span class="comment">//LNode 是普通类型，LinkList是指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建头结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">LinkList <span class="title function_">createHead_link</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 头插法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertFirst_link</span><span class="params">(LinkList, LinkType)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尾插法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertLast_link</span><span class="params">(LinkList, LinkType)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在指定位置插入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert_link</span><span class="params">(LinkList,<span class="type">int</span>, LinkType)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除节点（指定位置）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">removeNode_link</span><span class="params">(LinkList,<span class="type">int</span>,LinkType&amp;)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除节点（指定节点）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">removeNode_link</span><span class="params">(LinkList,LinkType)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 销毁链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destory_link</span><span class="params">(LinkList)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LINKLIST_H_ */</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/test/222/">数据结构（一）——顺序表（C语言实现）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-09-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/C-C/">C/C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/test/tags/%E9%A1%BA%E5%BA%8F%E8%A1%A8/">顺序表</a></span><div class="content"><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>数据结构是相互之间存在一种或多种特定关系的数据元素的集合。根据数据元素之间关系的不同特性，通常有如下4类基本结构:</p>
<ul>
<li>   集合：结构中的数据元素之间除了“同属于一个集合”的关系外，别无其他的关系。如：<strong>广义表</strong>。</li>
<li>   线性结构：结构中的数据元素之间存在一个对一个的关系。如：<strong>链表</strong>。</li>
<li>   树形结构：结构中的数据元素之间存在一个对多个的关系。如：<strong>二叉树</strong>。</li>
<li>   图（网）状结构：结构中的数据元素之间存在多个对多个的关系。如：<strong>图</strong>。</li>
</ul>
<p>在线性结构中，根据存储方式分为<strong>顺序表</strong>、<strong>链表</strong>，根据对表的操作限制，分为<strong>栈</strong>和<strong>队列</strong>。</p>
<p>顺序表的特征是，在内存中占用连续的存储单元，可以简单的理解为顺序表就是数组。只是根据需要，在实际应用中动态分配顺序表占用的内存单元。而数组是在编译的时候，预分配了指定大小的内存单元，因此如下代码段会在编译的时候报错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len = <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> arr[len];</span><br></pre></td></tr></table></figure>

<p>但是顺序表又会有数据全部的特点：可以根据下标直接访问、不方便插入和删除元素（因为需要移动后续的元素）。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="定义结构"><a href="#定义结构" class="headerlink" title="定义结构"></a>定义结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SeqType; <span class="comment">//存储单元类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	SeqType *elem; <span class="comment">//存储空间基地址</span></span><br><span class="line">	<span class="type">int</span> length; <span class="comment">//当前长度</span></span><br><span class="line">	<span class="type">int</span> listsize; <span class="comment">//当前分配的存储容量（以sizeof(ElemType)为单位）</span></span><br><span class="line">&#125; SqList;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结构体内，有三个元素：存储空间基地址，类似于数组首地址；当前长度，记录顺序表中有效存储单元个数；当前分配的存储容量，顺序表中，最多容纳的存储单元个数。<strong>当顺序表中所有存储单元已经被使用，在下次插入元素之前，需要新增存储单元</strong>。这点是数组所不具有的特性。</p>
</blockquote>
<p>*<strong>注：定义一个存储单元类型<code>SeqType</code>是为了使顺序表适和更多数据类型，使用的时候修改<code>SeqType</code>类型即可</strong>。</p>
<h2 id="定义操作"><a href="#定义操作" class="headerlink" title="定义操作"></a>定义操作</h2><h3 id="创建顺序表"><a href="#创建顺序表" class="headerlink" title="创建顺序表"></a>创建顺序表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建顺序表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SqList <span class="title function_">createList_sq</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">//SqList list;</span></span><br><span class="line">	<span class="comment">//return list;</span></span><br><span class="line"></span><br><span class="line">	SqList* <span class="built_in">list</span> = (SqList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SqList));</span><br><span class="line">	<span class="keyword">return</span> *<span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里提供两种创建顺序表的代码，一种是由系统分配list占用的内存，一种是自己动态分配的内存，需要在程序运行之前手动释放占用的内存空间。</p>
</blockquote>
<h3 id="初始化顺序表"><a href="#初始化顺序表" class="headerlink" title="初始化顺序表"></a>初始化顺序表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化顺序表</span></span><br><span class="line"><span class="comment"> * 返回1 表示初始化成功</span></span><br><span class="line"><span class="comment"> * 返回0 表示初始化失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">initList_sq</span><span class="params">(SqList &amp;L)</span> &#123; <span class="comment">//只有在C++中才会有引用的存在</span></span><br><span class="line">	L.elem = (SeqType *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SeqType) * LIST_INIT_SIZE);</span><br><span class="line">	<span class="keyword">if</span> (!L.elem)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//内存分配失败，存储空间不够</span></span><br><span class="line">	L.length = <span class="number">0</span>; <span class="comment">//表示顺序表为空</span></span><br><span class="line">	L.listsize = LIST_INIT_SIZE; <span class="comment">//表示顺序表里，最大存储单元个数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>分配顺序表的存储单元，初始化顺序表属性的值。</p>
</blockquote>
<h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入顺序表</span></span><br><span class="line"><span class="comment"> * 下标是负数就插入到结尾</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertList_sq</span><span class="params">(SqList &amp;L, <span class="type">int</span> index, SeqType val)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (index &gt; L.length) &#123; <span class="comment">//存储的下表超出顺序表实际的长度</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;插入的下标超出顺序表的实际长度&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (index &lt; <span class="number">0</span>) <span class="comment">//下标是负数，插入到结尾</span></span><br><span class="line">		index = L.length;</span><br><span class="line">	<span class="keyword">if</span> (L.length == L.listsize) &#123; <span class="comment">//顺序表的存储单元已经存满</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表的存储单元已满，继续分配新的存储单元。&quot;</span>);</span><br><span class="line">		SeqType* newBase = (SeqType*) <span class="built_in">realloc</span>(L.elem,</span><br><span class="line">				(L.listsize + LISTINCREMENT) * <span class="keyword">sizeof</span>(SeqType)); <span class="comment">//继续分配存储单元</span></span><br><span class="line">		<span class="keyword">if</span> (!newBase) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;分配内存单元失败&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		L.elem = newBase;</span><br><span class="line">		L.listsize += LISTINCREMENT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//寻找合适的插入位置，index后面的元素向后移动</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = L.length; i &gt; index; i--) &#123;</span><br><span class="line">		L.elem[i] = L.elem[i - <span class="number">1</span>]; <span class="comment">//向后移动</span></span><br><span class="line">	&#125;</span><br><span class="line">	L.elem[index] = val; <span class="comment">//插入元素</span></span><br><span class="line">	L.length++;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将元素插入到指定的位置。插入之前，需要先判断顺序表中是否已经存满，再根据需要新增存储单元，最后插入元素。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入顺序表（结尾的位置）</span></span><br><span class="line"><span class="comment"> * 与上面的函数是重名函数，这叫函数重载，在C++里面支持</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertList_sq</span><span class="params">(SqList &amp;L, SeqType val)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> insertList_sq(L, L.length, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>*<strong>引用和重载，是C++中才支持，因此需要在cpp文件中编译。</strong></p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除指定的元素</span></span><br><span class="line"><span class="comment"> * 返回0 找不到指定的元素，删除失败。</span></span><br><span class="line"><span class="comment"> * 返回1 找到待删除的元素，删除成功。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">removeList_sq</span><span class="params">(SqList &amp;L, SeqType val)</span> &#123;</span><br><span class="line">	<span class="type">int</span> index = <span class="number">-1</span>; <span class="comment">//记录匹配到的下标</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (L.elem[i] == val) &#123;</span><br><span class="line">			<span class="comment">//找到匹配的val，结束循环</span></span><br><span class="line">			index = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; index &lt; L.length - <span class="number">1</span>; index++) &#123;</span><br><span class="line">		L.elem[index] = L.elem[index + <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	L.length--;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除指定元素，需要先找到下标。依次移动下标后面的结点，修改length值。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据下标删除是指定的结点，并返回元素的值</span></span><br><span class="line"><span class="comment"> * 返回0 下标超出顺序表长度，删除失败。</span></span><br><span class="line"><span class="comment"> * 返回1 下标正确，删除元素，并且将已删除元素值转给elem</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">removeList_sq</span><span class="params">(SqList &amp;L, <span class="type">int</span> index, SeqType &amp;elem)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (index &gt;= L.length) <span class="comment">//下标超出顺序表的长度</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	index = index &lt; <span class="number">0</span> ? L.length : index; <span class="comment">//下标负数表示删除最后一个节点</span></span><br><span class="line">	elem = L.elem[index];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; L.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		L.elem[i] = L.elem[i + <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	L.length--;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>先取到指定下标的元素，赋值给elem，然后依次移动下标后面的结点。最后修改length值。</p>
</blockquote>
<h3 id="销毁顺序表"><a href="#销毁顺序表" class="headerlink" title="销毁顺序表"></a>销毁顺序表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 销毁顺序表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destoryList_sq</span><span class="params">(SqList &amp;L)</span> &#123;</span><br><span class="line">	<span class="built_in">free</span>(L.elem); <span class="comment">//释放存储空间</span></span><br><span class="line">	L.length = <span class="number">0</span>;</span><br><span class="line">	L.listsize = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//	free(&amp;L);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重点释放顺序表的存储单元。如果顺序表自身的内存也是动态分配的，需要手动释放。</p>
</blockquote>
<p>最后附上，头文件的定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sqlist.h</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 线性表的顺序存储</span></span><br><span class="line"><span class="comment"> *  Created on: 2016年8月30日</span></span><br><span class="line"><span class="comment"> *      Author: flueky</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SQLIST_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLIST_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INIT_SIZE 50</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTINCREMENT 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SeqType; <span class="comment">//存储单元类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	SeqType *elem; <span class="comment">//存储空间基地址</span></span><br><span class="line">	<span class="type">int</span> length; <span class="comment">//当前长度</span></span><br><span class="line">	<span class="type">int</span> listsize; <span class="comment">//当前分配的存储容量（以sizeof(ElemType)为单位）</span></span><br><span class="line">&#125; SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建顺序表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SqList <span class="title function_">createList_sq</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化顺序表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">initList_sq</span><span class="params">(SqList &amp;)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入顺序表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertList_sq</span><span class="params">(SqList &amp;,<span class="type">int</span> index,SeqType)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入顺序表（结尾的位置）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertList_sq</span><span class="params">(SqList &amp;,SeqType)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在顺序表中移除指定位置元素，下标从0开始</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">removeList_sq</span><span class="params">(SqList &amp;,<span class="type">int</span>,SeqType &amp;)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在顺序表中删除指定元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">removeList_sq</span><span class="params">(SqList &amp;,SeqType)</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 销毁顺序表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destoryList_sq</span><span class="params">(SqList &amp;)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* SQLIST_H_ */</span></span></span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/test/221/">Activity&amp;Fragment生命周期详解</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-06-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/Android/">Android</a></span><div class="content"><p>生命周期，是初学Android必须要掌握的一个知识点，也是面试时最常问的知识点。最近突然发现，公司架构中关于fragment使用的代码还不够完美。因此先决定先巩固一遍Fragment生命周期，连带着Activity生命周期（<strong>两者之间还是有很大的关联</strong>），再尝试改善现有代码。关于生命周期的概念，个人觉得，设计Android的工程师们，很大程度上参考了IOS。</p></div><a class="more" href="/test/221/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/test/220/">指针与引用</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-05-27</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/C-C/">C/C++</a></span><div class="content"><p>初学者分析指针和引用最常用的方式是写一个swap函数，分析传值还是传址的交换。</p>
<h1 id="普通变量交换"><a href="#普通变量交换" class="headerlink" title="普通变量交换"></a>普通变量交换</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n&quot;</span>,a,b);</span><br><span class="line">	</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n&quot;</span>,a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出</p>
<blockquote>
<p>交换前:1 2 <br/><br>交换后:2 1 <br/></p>
</blockquote>
<p>这里没什么好分析的。</p>
<h1 id="指针交换"><a href="#指针交换" class="headerlink" title="指针交换"></a>指针交换</h1><p>正确交换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>* p = &amp;a;</span><br><span class="line">    <span class="type">int</span>* q = &amp;b;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n\n&quot;</span>,*p,*q);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>* temp = p;</span><br><span class="line">    p = q;</span><br><span class="line">    q = temp;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n&quot;</span>,*p,*q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>交换前:1 2 <br/><br>交换前:1 2 <br/></p>
<p>交换后:1 2 <br/><br>交换后:2 1 <br/></p>
</blockquote>
<p>现在就变得有意思了。最初p、q分别指向a和b的地址。表示p-&gt;a,q-&gt;b。经过交换之后，p-&gt;b,q-&gt;a。</p>
<p>错误交换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>* p = &amp;a;</span><br><span class="line">    <span class="type">int</span>* q = &amp;b;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n\n&quot;</span>,*p,*q);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>* temp = p;</span><br><span class="line">    *p = *q;<span class="comment">//注意这里的不同</span></span><br><span class="line">    q = temp;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n&quot;</span>,*p,*q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>交换前:1 2 <br/><br>交换前:1 2 <br/></p>
</blockquote>
<blockquote>
<p>交换后:2 2 <br/><br>交换后:2 2 <br/></p>
</blockquote>
<p>代码<code>*p = *q</code>等价于<code>a=b</code>。所以第一个会输出2 2。需要注意的是，此时p 和 q 依然指向不同的地址。执行完代码<code>q = temp</code> q 和p 指向相同的地址了。因为最初<code>temp = p</code>。</p>
<p>也有的人写成这样的交换方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//案例1</span></span><br><span class="line"><span class="type">int</span> temp = *p;</span><br><span class="line">   *p = *q;</span><br><span class="line">   *q = temp;</span><br><span class="line"><span class="comment">//案例2</span></span><br><span class="line">   <span class="type">int</span> temp = *p;</span><br><span class="line">   p = q;</span><br><span class="line">   *q = temp;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>案例1 <br/><br>交换后:2 1 <br/><br>交换后:2 1 <br/></p>
</blockquote>
<blockquote>
<p>案例2 有<code>*q = temp</code> <br/><br>交换后:1 1 <br/><br>交换后:1 1 <br/></p>
</blockquote>
<blockquote>
<p>案例2 没有<code>*q = temp</code> <br/><br>交换后:1 2 <br/><br>交换后:2 2 <br/></p>
</blockquote>
<p>关于案例1，等价于普通变量的交换。最终交换的是a 和 b的值。p和q的指针不变。案例2中，先给temp赋a 的值，再将p的指针指向q，最后修改q指向的值。得出最终结果p &#x3D; q-&gt;b &#x3D; a &#x3D; 1。如果没有	<code>*q = temp</code>最终结果p &#x3D; q-&gt;b &#x3D; 2，a &#x3D; 1</p>
<h1 id="二重指针交换"><a href="#二重指针交换" class="headerlink" title="二重指针交换"></a>二重指针交换</h1><p>正常交换</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>* p = &amp;a;</span><br><span class="line">    <span class="type">int</span>* q = &amp;b;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>** pp = &amp;p;</span><br><span class="line">    <span class="type">int</span>** qq = &amp;q;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n&quot;</span>,*p,*q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n\n&quot;</span>,**pp,**qq);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>** temp = pp;</span><br><span class="line">    pp = qq;</span><br><span class="line">    qq = temp;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n&quot;</span>,*p,*q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n&quot;</span>,**pp,**qq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>交换前:1 2 <br/><br>交换前:1 2 <br/><br>交换前:1 2 <br/></p>
</blockquote>
<blockquote>
<p>交换后:1 2 <br/><br>交换后:1 2 <br/><br>交换后:2 1 <br/></p>
</blockquote>
<p>简单分析：最初时，pp-&gt;p-&gt;a,qq-&gt;q-&gt;b。交换后：qq-&gt;p-&gt;a,pp-&gt;q-&gt;b。弄懂了二重指针的道理，之后遇到三重、四重指针时，可以递归分析。</p>
<p>错误交换</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>* p = &amp;a;</span><br><span class="line">    <span class="type">int</span>* q = &amp;b;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>** pp = &amp;p;</span><br><span class="line">    <span class="type">int</span>** qq = &amp;q;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n&quot;</span>,*p,*q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n\n&quot;</span>,**pp,**qq);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>** temp = pp;</span><br><span class="line">    **pp = **qq;<span class="comment">//注意此处的不同</span></span><br><span class="line">    qq = temp;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n&quot;</span>,*p,*q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n&quot;</span>,**pp,**qq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>交换后:2 2 <br/><br>交换后:2 2 <br/><br>交换后:2 2 <br/></p>
</blockquote>
<p>之前也说过了，此处<code>**pp = **qq</code>相当于<code>a = b</code>所以pp-&gt;p-&gt;a &#x3D; 2；qq-&gt;q-&gt;b &#x3D; 2;因此输出全是2。执行<code>qq = temp</code>使得qq&#x3D;pp-&gt;p-&gt;a &#x3D; 2，并没有改变q-&gt;b &#x3D; 2。</p>
<p>看到这里有没有晕？接下来举几个一定能让你晕的案例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//案例1</span></span><br><span class="line">   <span class="type">int</span>** temp = pp;</span><br><span class="line">   *pp = *qq;</span><br><span class="line">   qq = temp;</span><br><span class="line"><span class="comment">//案例2</span></span><br><span class="line">   <span class="type">int</span>* temp = *pp;</span><br><span class="line">   **pp = **qq;</span><br><span class="line">   *qq = temp;</span><br><span class="line"><span class="comment">//案例3</span></span><br><span class="line"><span class="type">int</span>* temp = *pp;</span><br><span class="line">   *pp = *qq;</span><br><span class="line">   *qq = temp;</span><br><span class="line"><span class="comment">//案例4</span></span><br><span class="line"><span class="type">int</span>* temp = *pp;</span><br><span class="line">   pp = qq;</span><br><span class="line">   *qq = temp;</span><br><span class="line"><span class="comment">//案例5</span></span><br><span class="line">   <span class="type">int</span> temp = **pp;</span><br><span class="line">   pp = qq;</span><br><span class="line">   **qq = temp;</span><br><span class="line">	<span class="comment">//案例6   </span></span><br><span class="line">   <span class="type">int</span> temp = **pp;</span><br><span class="line">   *pp = *qq;</span><br><span class="line">   **qq = temp;</span><br><span class="line"><span class="comment">//案例7</span></span><br><span class="line">   <span class="type">int</span> temp = **pp;</span><br><span class="line">   **pp = **qq;</span><br><span class="line">   **qq = temp;</span><br></pre></td></tr></table></figure>

<p>加上之前的两个，这里包含了二重指针置换的所有的可能的写法。</p>
<blockquote>
<p>案例1 <br/><br>交换后:1 2 <br/><br>交换后:2 2 <br/><br>交换后:2 2 <br/></p>
</blockquote>
<p>执行<code>*pp = *qq</code>，pp-&gt;p&#x3D;q-&gt;b&#x3D;2,qq-&gt;q-&gt;b&#x3D;2。执行<code>qq = temp</code>，qq&#x3D;pp-&gt;p&#x3D;q-&gt;b&#x3D;2。而此时a&#x3D;1，b&#x3D;2不变。</p>
<blockquote>
<p>案例2 <br/><br>交换后:2 2 <br/><br>交换后:2 2 <br/><br>交换后:2 2 <br/></p>
</blockquote>
<p>执行<code>**pp = **qq</code>，pp-&gt;p-&gt;a&#x3D;b&#x3D;2,qq-&gt;q-&gt;b&#x3D;2。执行	<code>*qq = temp</code>，pp-&gt;p-&gt;a&#x3D;b&#x3D;2,qq-&gt;q&#x3D;p-&gt;a&#x3D;2。<strong>分析这里时，可将<code>**pp = **qq</code>等价成<code>a = b</code>而<code>*qq = temp</code>等价成q &#x3D; temp &#x3D; p</strong>。</p>
<blockquote>
<p>案例3 <br/><br>交换后:1 2 <br/><br>交换后:2 1 <br/><br>交换后:2 1 <br/></p>
</blockquote>
<p>用通俗的话讲，这里交换的是p和q 两个指针（等价于一重指针的正确案例）。pp-&gt;p-&gt;b &#x3D; 2,qq-&gt;q-&gt;a &#x3D; 1;</p>
<blockquote>
<p>案例4 <br/><br>交换后:1 2 <br/><br>交换后:1 1 <br/><br>交换后:1 1 <br/></p>
</blockquote>
<p>执行<code>pp = qq</code>，pp&#x3D;qq-&gt;q-&gt;b&#x3D;2,p-&gt;a&#x3D;1。执行<code> *qq = temp</code>,等价于<code>q = p</code>,所以pp&#x3D;qq-&gt;q&#x3D;p-&gt;a&#x3D;1，b&#x3D;2。</p>
<blockquote>
<p>案例5 <br/><br>交换后:1 1 <br/><br>交换后:1 1 <br/><br>交换后:1 1 <br/></p>
</blockquote>
<p>执行<code>pp = qq</code>,pp&#x3D;qq-&gt;q-&gt;b&#x3D;2,p-&gt;a&#x3D;1。执行<code>**qq = temp</code>等价于<code>**qq = **pp，b = a</code>，因此pp&#x3D;qq-&gt;q-&gt;b&#x3D;a &#x3D; 1,p-&gt;a&#x3D;1</p>
<blockquote>
<p>案例6 <br/><br>交换后:1 1 <br/><br>交换后:1 1 <br/><br>交换后:1 1 <br/></p>
</blockquote>
<p>执行<code>*pp = *qq</code>，等价于<code>p = q</code>，pp-&gt;p&#x3D;q-&gt;b&#x3D;2,qq-&gt;q-&gt;b&#x3D;2,a&#x3D;1。执行<code>**qq = temp</code>，pp-&gt;p&#x3D;q-&gt;b&#x3D;a&#x3D;1,qq-&gt;q-&gt;b&#x3D;a&#x3D;1。</p>
<blockquote>
<p>案例7 <br/><br>交换后:2 1 <br/><br>交换后:2 1 <br/><br>交换后:2 1 <br/></p>
</blockquote>
<p>一句话的总结就是：交换了a和b。pp-&gt;p-&gt;a &#x3D; 2,qq-&gt;q-&gt;b &#x3D; 1。</p>
<h1 id="引用交换"><a href="#引用交换" class="headerlink" title="引用交换"></a>引用交换</h1><p>引用是C++中才有的概念，因此在c文件中测试如下代码，会在编译时候产生语法错误。需要创建cpp文件测试。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>&amp; r = a;</span><br><span class="line">    <span class="type">int</span>&amp; s = b;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n\n&quot;</span>,r,s);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>&amp; temp = r;</span><br><span class="line">    r = s;</span><br><span class="line">    s = temp;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n&quot;</span>,r,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>交换前:1 2 <br/><br>交换前:1 2 <br/></p>
<p>交换后:2 2 <br/><br>交换后:2 2 <br/></p>
</blockquote>
<p>运行后发现，这里并没有起到交换的作用。究其原因，定义temp 引用时，temp 和 r指向内存中同一块，也就是a所在的内存。引用之间只能够传值（指针之间可以传止，如p &#x3D; q使 p&#x3D;q-&gt;b&#x3D;2，a&#x3D;1），r &#x3D; s &#x3D; b &#x3D; 2，于是temp &#x3D; 2，a &#x3D; 2。s &#x3D; temp &#x3D; 2。</p>
<p>正确的交换应当是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> temp = r;<span class="comment">//注意这里的不同</span></span><br><span class="line">r = s;</span><br><span class="line">s = temp;</span><br></pre></td></tr></table></figure>

<p>这样就得到了预期的运行结果。啊哦……</p>
<blockquote>
<p>交换前:1 2 <br/><br>交换前:1 2 <br/></p>
<p>交换后:2 1 <br/><br>交换后:2 1 <br/></p>
</blockquote>
<h1 id="函数交换"><a href="#函数交换" class="headerlink" title="函数交换"></a>函数交换</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通交换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">swap</span>(a, b);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n\n&quot;</span>,a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n&quot;</span>,a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>交换前:1 2 <br/></p>
<p>交换后:1 2 <br/></p>
</blockquote>
<p>swap 函数中的a、b是形参，main函数中，传入的是a、b 的值，所以在swap函数中交换的是形参a、b的值，不影响main函数中a、b的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指针交换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapP</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span>* p = &amp;a;</span><br><span class="line">    <span class="type">int</span>* q = &amp;b;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n\n&quot;</span>,*p,*q);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">swapP</span>(&amp;a, &amp;b);</span><br><span class="line"><span class="comment">//    swapP(p, q);//等价上句</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n\n&quot;</span>,*p,*q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>交换前:1 2 <br/><br>交换前:1 2 <br/></p>
<p>交换后:2 1 <br/><br>交换后:2 1 <br/></p>
</blockquote>
<p>swapP函数两个参数都是指针类型，接收main函数中的指针p或a的地址（<strong>指针p 指向a的地址，同理b</strong>），因此在swap中交换的依然是a和b的值，不改变main函数中p-&gt;a,q-&gt;b。</p>
<p>错误交换示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指针交换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapP</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span>* temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>交换前:1 2 <br/><br>交换前:1 2 <br/></p>
<p>交换后:1 2 <br/><br>交换后:1 2 <br/></p>
</blockquote>
<p>这里是对指针指向的地址进行交换，而这里的指针依然是形参，交换后的值不改变main函数中的p、q。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二重指针交换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapPP</span><span class="params">(<span class="type">int</span>** pp,<span class="type">int</span> **qq)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span>* temp = *pp;</span><br><span class="line">    *pp = *qq;</span><br><span class="line">    *qq = temp;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span>* p = &amp;a;</span><br><span class="line">    <span class="type">int</span>* q = &amp;b;</span><br><span class="line">    <span class="type">int</span>** pp = &amp;p;</span><br><span class="line">    <span class="type">int</span>** qq = &amp;q;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n&quot;</span>,*p,*q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n\n&quot;</span>,**pp,**qq);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">swapPP</span>(pp, qq);</span><br><span class="line"><span class="comment">//    swapPP(&amp;p, &amp;q);//等价上句</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n&quot;</span>,*p,*q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n\n&quot;</span>,**pp,**qq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>交换前:1 2 <br/><br>交换前:1 2 <br/><br>交换前:1 2 <br/></p>
<p>交换后:1 2 <br/><br>交换后:2 1 <br/><br>交换后:2 1 <br/></p>
</blockquote>
<blockquote>
<p>交换前：pp-&gt;p-&gt;a &#x3D; 1,qq-&gt;q-&gt;b &#x3D; 2;<br>交换后：pp-&gt;p-&gt;b &#x3D; 2,qq-&gt;q-&gt;a &#x3D; 1;换句话说，交换了p和q指向的地址。</p>
</blockquote>
<p>错误交换示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二重指针交换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapPP1</span><span class="params">(<span class="type">int</span>** pp,<span class="type">int</span> **qq)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span>** temp = pp;</span><br><span class="line">    pp = qq;</span><br><span class="line">    qq = temp;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>交换前:1 2 <br/><br>交换前:1 2 <br/><br>交换前:1 2 <br/></p>
<p>交换后:1 2 <br/><br>交换后:1 2 <br/><br>交换后:1 2 <br/></p>
</blockquote>
<p>原理同一重指针的错误交换示例。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 引用交换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapR</span><span class="params">(<span class="type">int</span>&amp; a,<span class="type">int</span>&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>&amp; r = a;</span><br><span class="line">    <span class="type">int</span>&amp; s = b;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n\n&quot;</span>,r,s);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">swapR</span>(r,s);</span><br><span class="line"><span class="comment">//    swapR(a,b);//等价上句</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n&quot;</span>,r,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>交换前:1 2 <br/><br>交换前:1 2 <br/></p>
<p>交换后:2 1 <br/><br>交换后:2 1 <br/></p>
</blockquote>
<p>原理同一重指针的正确交换。这里传入的是a、b的地址。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>正确的交换代码片段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* temp = p;</span><br><span class="line">p = q;</span><br><span class="line">q = temp;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>** temp = pp;</span><br><span class="line">pp = qq;</span><br><span class="line">qq = temp;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* temp = *pp;</span><br><span class="line">*pp = *qq;</span><br><span class="line">*qq = temp;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> temp = r;</span><br><span class="line">r = s;</span><br><span class="line">s = temp;</span><br></pre></td></tr></table></figure>

<p><strong>注意二重指针的两种交换，在函数中只有一种是有效的</strong></p>
<p><strong>谨以此篇博文，欢迎加入我们软件实验室的新生……</strong></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/test/219s/">分分钟修改Android keystore</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-05-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/Android/">Android</a></span><div class="content"><p>之前写过一篇博客[Android开发必备技能——修改debug签名](&#x2F;blog&#x2F;2016-05-04&#x2F;)，感觉对不习惯使用Linux命令的小伙伴而言，简直是噩梦。因此奉上简单实用的Java代码。</p></div><a class="more" href="/test/219s/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/test/218/">Android开发必备技能——修改debug签名</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-05-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a></span><div class="content"><p>从事Android开发的小伙伴们，想必都会遇到这样的问题。当你的应用中需要集成百度地图、极光推送等第三方平台时，会去申请一个叫做AppKey的东西。与此同时，你得提供下应用签名信息的MD5或SHA1。然后就悲催的发现，只有用指定的签名文件打包时，该功能才能正常使用。如果你用的是开发工具的debug keystore签名信息，直接run一下就好，如果你用的是APP发布时候的keystore，每次测试时都得export 一个apk。心中一万只草泥马在奔腾的有木有？</p></div><a class="more" href="/test/218/#more">Read more</a><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/test/page/3/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/test/">1</a><span class="space">&hellip;</span><a class="page-number" href="/test/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/test/page/5/">5</a><a class="page-number" href="/test/page/6/">6</a><a class="extend next" rel="next" href="/test/page/5/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2016 - 2024 By flueky</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/test/js/utils.js?version=1.9.1"></script><script src="/test/js/fancybox.js?version=1.9.1"></script><script src="/test/js/sidebar.js?version=1.9.1"></script><script src="/test/js/copy.js?version=1.9.1"></script><script src="/test/js/fireworks.js?version=1.9.1"></script><script src="/test/js/transition.js?version=1.9.1"></script><script src="/test/js/scroll.js?version=1.9.1"></script><script src="/test/js/head.js?version=1.9.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>