<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="小飞哥的个人博客主页"><meta name="keywords" content=""><meta name="author" content="flueky"><meta name="copyright" content="flueky"><title>Android 程序猿秘籍 | Flueky 技术小站</title><link rel="shortcut icon" href="/test/melody-favicon.ico"><link rel="stylesheet" href="/test/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/test/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/test/img/avatar.png"></div><div class="author-info__name text-center">flueky</div><div class="author-info__description text-center">小飞哥的个人博客主页</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/test/archives"><span class="pull-left">Articles</span><span class="pull-right">63</span></a><a class="author-info-articles__tags article-meta" href="/test/tags"><span class="pull-left">Tags</span><span class="pull-right">20</span></a><a class="author-info-articles__categories article-meta" href="/test/categories"><span class="pull-left">Categories</span><span class="pull-right">11</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/test/">Flueky 技术小站</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right"></span></div><div id="site-info"><div id="site-title">Flueky 技术小站</div><div id="site-sub-title">Android 程序猿秘籍</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/test/224/">Java多线程示例——模拟银行柜台处理业务</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-10-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/Java/">Java</a></span><div class="content"><p>前不久看到一个题目<a target="_blank" rel="noopener" href="http://ask.csdn.net/questions/336334">模拟银行柜台处理业务</a>觉得很有意思，模拟银行柜台处理业务，考察的多线程编程，以及多线程间通信。由于以前没有系统学习过Java，工作中也是根据实际需要，去选择Java的一个部分再次学习。所以多线程编程一直是自己的软肋。甚至分不清实现Runnable接口和继承Thread类的区别。顺便问一下有人知道实现多线程编程的第三种方式么？在处理这个问题之前，先看了一遍《疯狂Java讲义》（这本书用来Java编程入门足以）中关于多线程的章节，心中关于题目中实现线程间通信也有了几种不同的方案，这里根据实际需要选择最容易实现的一种。</p></div><a class="more" href="/test/224/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/test/223/">数据结构（二）——链表（C语言实现）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-09-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/C-C/">C/C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/test/tags/%E9%93%BE%E8%A1%A8/">链表</a></span><div class="content"><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>相对于顺序表而言，“勤拿少取”这是对链表最形象的描述。意指，它需要一个结点，就在内存中分配一块内存单元。比顺序表不足的是，链表的每个结点中，需要一个存储单元保存指向下一个结点的地址。</p>
<p>链表的访问需要从第一个结点（或称头结点）开始寻找，（顺序表可以根据下标直接访问）。链表的插入和删除只需对指定位置的结点操作即可。</p>
<p>常见的链表，根据指向下个链表的指针可分为<strong>单向链表</strong>，<strong>双向链表</strong>。根据第一个结点是否存储元素可分为<strong>带头结点的链表</strong>和<strong>不带头结点的链表</strong>。再根据末尾结点next指针的指向可分为<strong>循环链表</strong>和<strong>非循环链表</strong>。</p>
<p>*<strong>下面程序以单向带头结点的非循环链表为例</strong>。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="定义结构"><a href="#定义结构" class="headerlink" title="定义结构"></a>定义结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> LinkType; <span class="comment">//存储单元类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">linkNode</span> &#123;</span></span><br><span class="line">	LinkType key; <span class="comment">//结点的key值</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">linkNode</span> *<span class="title">next</span>;</span> <span class="comment">//指向下一个结点</span></span><br><span class="line">&#125; LNode, *LinkList;<span class="comment">//LNode 是普通类型，LinkList是指针类型</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>定义LinkType类型，使该链表结构适合更多数据类型。每个链表的结点，包含一个值域key和一个指针域next。这里声明两种类型<code>LNode</code>和<code>LinkList</code>。以下两行代码是等价的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LNode* node = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">LinkList node = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br></pre></td></tr></table></figure>

<h2 id="定义操作"><a href="#定义操作" class="headerlink" title="定义操作"></a>定义操作</h2><h3 id="创建头结点"><a href="#创建头结点" class="headerlink" title="创建头结点"></a>创建头结点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建头结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">LinkList <span class="title function_">createHead_link</span><span class="params">()</span> &#123;</span><br><span class="line">	LinkList head = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里是动态分配一个内存单元存储头结点，也可以参照<a target="_blank" rel="noopener" href="http://blog.csdn.net/flueky/article/details/52711668">顺序表</a>中，使用<code>LNode head</code>，由系统分配内存。<a href="%5B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E9%A1%BA%E5%BA%8F%E8%A1%A8%EF%BC%88C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%EF%BC%89%5D(http://blog.csdn.net/flueky/article/details/52711668)">^footnote</a></p>
</blockquote>
<h3 id="插入结点"><a href="#插入结点" class="headerlink" title="插入结点"></a>插入结点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 头插法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertFirst_link</span><span class="params">(LinkList head, LinkType val)</span> &#123;</span><br><span class="line">	LinkList node = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	node-&gt;key = val;</span><br><span class="line">	node-&gt;next = head-&gt;next;</span><br><span class="line">	head-&gt;next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在带头结点的链表中，头插法表示每次将结点插入到头结点的后面。在不带头结点的链表中，将待插入的结点放在链表中第一个结点的前面，代替之成为第一个结点。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尾插法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertLast_link</span><span class="params">(LinkList head, LinkType val)</span> &#123;</span><br><span class="line">	LinkList temp = head;</span><br><span class="line">	<span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>) <span class="comment">//找到末尾结点</span></span><br><span class="line">		temp = temp-&gt;next;</span><br><span class="line">	LinkList node = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	node-&gt;key = val;</span><br><span class="line">	temp-&gt;next = node;</span><br><span class="line">	node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于尾插法而言，不区分带头结点和不带头结点的链表。只将待插入的结点插到链表的最后一个位置。因此需要先循环到链表的末尾。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定位置插入，position表示插入后的位置，0表示头结点后的第一个结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert_link</span><span class="params">(LinkList head, <span class="type">int</span> position, LinkType val)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (position &lt; <span class="number">0</span>) <span class="comment">//-1 从末尾添加，采用尾插法</span></span><br><span class="line">		insertLast_link(head, val);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (position == <span class="number">0</span>) <span class="comment">//从第一个结点插入，采用头插法</span></span><br><span class="line">		insertFirst_link(head, val);</span><br><span class="line">	<span class="keyword">else</span> &#123; <span class="comment">//</span></span><br><span class="line">		LinkList temp = head-&gt;next;</span><br><span class="line">		<span class="keyword">while</span> (temp != <span class="literal">NULL</span> &amp;&amp; --position &gt; <span class="number">0</span>) &#123; <span class="comment">//找到合适的位置结点</span></span><br><span class="line">			temp = temp-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		LinkList node = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">		node-&gt;key = val;</span><br><span class="line">		node-&gt;next = temp-&gt;next;</span><br><span class="line">		temp-&gt;next = node;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>先根据下标找到待插入的位置，然后插入结点。对比顺序表，先移动指定位置的后续结点，再插入新的结点。</p>
</blockquote>
<h3 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除节点（指定位置）,下标从0开始</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">removeNode_link</span><span class="params">(LinkList head, <span class="type">int</span> index, LinkType &amp;key)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;指定下标值不正确\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LinkList node = head;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!node-&gt;next || i &lt; index) &#123; <span class="comment">//寻找指定下标的节点，结束循环时，i==index</span></span><br><span class="line">		node = node-&gt;next;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (i == index) &#123; <span class="comment">//找到指定节点</span></span><br><span class="line">		LinkList temp = node-&gt;next; <span class="comment">//temp 是要被删除的节点</span></span><br><span class="line">		node-&gt;next = temp-&gt;next;</span><br><span class="line">		temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		key = temp-&gt;key;</span><br><span class="line">		<span class="built_in">free</span>(temp);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">//没找到</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;没找到指定下标的值&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>下标从0开始，表示头结点后的第一个结点。先找到待删除的结点，取出key值，再删除该结点。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除节点（指定节点）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">removeNode_link</span><span class="params">(LinkList head, LinkType val)</span> &#123;</span><br><span class="line">	LinkList node = head;</span><br><span class="line">	<span class="keyword">while</span> (!node-&gt;next) &#123;</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;next-&gt;key == val)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		node = node-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (node-&gt;next != <span class="literal">NULL</span>) &#123; <span class="comment">//找到要删除的节点</span></span><br><span class="line">		LinkList temp = node-&gt;next; <span class="comment">//temp 是要被删除的节点</span></span><br><span class="line">		node-&gt;next = temp-&gt;next;</span><br><span class="line">		temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="built_in">free</span>(temp);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;没找到要删除的节点\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>首先根据val值，找到待删除的结点，最后删除之。</p>
</blockquote>
<h3 id="销毁链表"><a href="#销毁链表" class="headerlink" title="销毁链表"></a>销毁链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 销毁链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destory_link</span><span class="params">(LinkList head)</span> &#123;</span><br><span class="line">	<span class="keyword">while</span> (head-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		LinkList node = head-&gt;next;</span><br><span class="line">		head-&gt;next = node-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(node);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>释放掉除头结点之外的所有结点占用的内存。</p>
</blockquote>
<p>最后附上，头文件的定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * linklist.h</span></span><br><span class="line"><span class="comment"> * 顺序表的链式存储结构</span></span><br><span class="line"><span class="comment"> *  Created on: 2016年8月30日</span></span><br><span class="line"><span class="comment"> *      Author: flueky</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LINKLIST_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LINKLIST_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> LinkType; <span class="comment">//存储单元类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">linkNode</span> &#123;</span></span><br><span class="line">	LinkType key; <span class="comment">//节点的key值</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">linkNode</span> *<span class="title">next</span>;</span> <span class="comment">//指向下一个节点</span></span><br><span class="line">&#125; LNode, *LinkList;<span class="comment">//LNode 是普通类型，LinkList是指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建头结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">LinkList <span class="title function_">createHead_link</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 头插法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertFirst_link</span><span class="params">(LinkList, LinkType)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尾插法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertLast_link</span><span class="params">(LinkList, LinkType)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在指定位置插入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert_link</span><span class="params">(LinkList,<span class="type">int</span>, LinkType)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除节点（指定位置）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">removeNode_link</span><span class="params">(LinkList,<span class="type">int</span>,LinkType&amp;)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除节点（指定节点）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">removeNode_link</span><span class="params">(LinkList,LinkType)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 销毁链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destory_link</span><span class="params">(LinkList)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LINKLIST_H_ */</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/test/222/">数据结构（一）——顺序表（C语言实现）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-09-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/C-C/">C/C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/test/tags/%E9%A1%BA%E5%BA%8F%E8%A1%A8/">顺序表</a></span><div class="content"><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>数据结构是相互之间存在一种或多种特定关系的数据元素的集合。根据数据元素之间关系的不同特性，通常有如下4类基本结构:</p>
<ul>
<li>   集合：结构中的数据元素之间除了“同属于一个集合”的关系外，别无其他的关系。如：<strong>广义表</strong>。</li>
<li>   线性结构：结构中的数据元素之间存在一个对一个的关系。如：<strong>链表</strong>。</li>
<li>   树形结构：结构中的数据元素之间存在一个对多个的关系。如：<strong>二叉树</strong>。</li>
<li>   图（网）状结构：结构中的数据元素之间存在多个对多个的关系。如：<strong>图</strong>。</li>
</ul>
<p>在线性结构中，根据存储方式分为<strong>顺序表</strong>、<strong>链表</strong>，根据对表的操作限制，分为<strong>栈</strong>和<strong>队列</strong>。</p>
<p>顺序表的特征是，在内存中占用连续的存储单元，可以简单的理解为顺序表就是数组。只是根据需要，在实际应用中动态分配顺序表占用的内存单元。而数组是在编译的时候，预分配了指定大小的内存单元，因此如下代码段会在编译的时候报错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len = <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> arr[len];</span><br></pre></td></tr></table></figure>

<p>但是顺序表又会有数据全部的特点：可以根据下标直接访问、不方便插入和删除元素（因为需要移动后续的元素）。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="定义结构"><a href="#定义结构" class="headerlink" title="定义结构"></a>定义结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SeqType; <span class="comment">//存储单元类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	SeqType *elem; <span class="comment">//存储空间基地址</span></span><br><span class="line">	<span class="type">int</span> length; <span class="comment">//当前长度</span></span><br><span class="line">	<span class="type">int</span> listsize; <span class="comment">//当前分配的存储容量（以sizeof(ElemType)为单位）</span></span><br><span class="line">&#125; SqList;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结构体内，有三个元素：存储空间基地址，类似于数组首地址；当前长度，记录顺序表中有效存储单元个数；当前分配的存储容量，顺序表中，最多容纳的存储单元个数。<strong>当顺序表中所有存储单元已经被使用，在下次插入元素之前，需要新增存储单元</strong>。这点是数组所不具有的特性。</p>
</blockquote>
<p>*<strong>注：定义一个存储单元类型<code>SeqType</code>是为了使顺序表适和更多数据类型，使用的时候修改<code>SeqType</code>类型即可</strong>。</p>
<h2 id="定义操作"><a href="#定义操作" class="headerlink" title="定义操作"></a>定义操作</h2><h3 id="创建顺序表"><a href="#创建顺序表" class="headerlink" title="创建顺序表"></a>创建顺序表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建顺序表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SqList <span class="title function_">createList_sq</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">//SqList list;</span></span><br><span class="line">	<span class="comment">//return list;</span></span><br><span class="line"></span><br><span class="line">	SqList* <span class="built_in">list</span> = (SqList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SqList));</span><br><span class="line">	<span class="keyword">return</span> *<span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里提供两种创建顺序表的代码，一种是由系统分配list占用的内存，一种是自己动态分配的内存，需要在程序运行之前手动释放占用的内存空间。</p>
</blockquote>
<h3 id="初始化顺序表"><a href="#初始化顺序表" class="headerlink" title="初始化顺序表"></a>初始化顺序表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化顺序表</span></span><br><span class="line"><span class="comment"> * 返回1 表示初始化成功</span></span><br><span class="line"><span class="comment"> * 返回0 表示初始化失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">initList_sq</span><span class="params">(SqList &amp;L)</span> &#123; <span class="comment">//只有在C++中才会有引用的存在</span></span><br><span class="line">	L.elem = (SeqType *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SeqType) * LIST_INIT_SIZE);</span><br><span class="line">	<span class="keyword">if</span> (!L.elem)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//内存分配失败，存储空间不够</span></span><br><span class="line">	L.length = <span class="number">0</span>; <span class="comment">//表示顺序表为空</span></span><br><span class="line">	L.listsize = LIST_INIT_SIZE; <span class="comment">//表示顺序表里，最大存储单元个数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>分配顺序表的存储单元，初始化顺序表属性的值。</p>
</blockquote>
<h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入顺序表</span></span><br><span class="line"><span class="comment"> * 下标是负数就插入到结尾</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertList_sq</span><span class="params">(SqList &amp;L, <span class="type">int</span> index, SeqType val)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (index &gt; L.length) &#123; <span class="comment">//存储的下表超出顺序表实际的长度</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;插入的下标超出顺序表的实际长度&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (index &lt; <span class="number">0</span>) <span class="comment">//下标是负数，插入到结尾</span></span><br><span class="line">		index = L.length;</span><br><span class="line">	<span class="keyword">if</span> (L.length == L.listsize) &#123; <span class="comment">//顺序表的存储单元已经存满</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表的存储单元已满，继续分配新的存储单元。&quot;</span>);</span><br><span class="line">		SeqType* newBase = (SeqType*) <span class="built_in">realloc</span>(L.elem,</span><br><span class="line">				(L.listsize + LISTINCREMENT) * <span class="keyword">sizeof</span>(SeqType)); <span class="comment">//继续分配存储单元</span></span><br><span class="line">		<span class="keyword">if</span> (!newBase) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;分配内存单元失败&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		L.elem = newBase;</span><br><span class="line">		L.listsize += LISTINCREMENT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//寻找合适的插入位置，index后面的元素向后移动</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = L.length; i &gt; index; i--) &#123;</span><br><span class="line">		L.elem[i] = L.elem[i - <span class="number">1</span>]; <span class="comment">//向后移动</span></span><br><span class="line">	&#125;</span><br><span class="line">	L.elem[index] = val; <span class="comment">//插入元素</span></span><br><span class="line">	L.length++;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将元素插入到指定的位置。插入之前，需要先判断顺序表中是否已经存满，再根据需要新增存储单元，最后插入元素。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入顺序表（结尾的位置）</span></span><br><span class="line"><span class="comment"> * 与上面的函数是重名函数，这叫函数重载，在C++里面支持</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertList_sq</span><span class="params">(SqList &amp;L, SeqType val)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> insertList_sq(L, L.length, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>*<strong>引用和重载，是C++中才支持，因此需要在cpp文件中编译。</strong></p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除指定的元素</span></span><br><span class="line"><span class="comment"> * 返回0 找不到指定的元素，删除失败。</span></span><br><span class="line"><span class="comment"> * 返回1 找到待删除的元素，删除成功。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">removeList_sq</span><span class="params">(SqList &amp;L, SeqType val)</span> &#123;</span><br><span class="line">	<span class="type">int</span> index = <span class="number">-1</span>; <span class="comment">//记录匹配到的下标</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (L.elem[i] == val) &#123;</span><br><span class="line">			<span class="comment">//找到匹配的val，结束循环</span></span><br><span class="line">			index = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; index &lt; L.length - <span class="number">1</span>; index++) &#123;</span><br><span class="line">		L.elem[index] = L.elem[index + <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	L.length--;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除指定元素，需要先找到下标。依次移动下标后面的结点，修改length值。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据下标删除是指定的结点，并返回元素的值</span></span><br><span class="line"><span class="comment"> * 返回0 下标超出顺序表长度，删除失败。</span></span><br><span class="line"><span class="comment"> * 返回1 下标正确，删除元素，并且将已删除元素值转给elem</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">removeList_sq</span><span class="params">(SqList &amp;L, <span class="type">int</span> index, SeqType &amp;elem)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (index &gt;= L.length) <span class="comment">//下标超出顺序表的长度</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	index = index &lt; <span class="number">0</span> ? L.length : index; <span class="comment">//下标负数表示删除最后一个节点</span></span><br><span class="line">	elem = L.elem[index];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; L.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		L.elem[i] = L.elem[i + <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	L.length--;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>先取到指定下标的元素，赋值给elem，然后依次移动下标后面的结点。最后修改length值。</p>
</blockquote>
<h3 id="销毁顺序表"><a href="#销毁顺序表" class="headerlink" title="销毁顺序表"></a>销毁顺序表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 销毁顺序表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destoryList_sq</span><span class="params">(SqList &amp;L)</span> &#123;</span><br><span class="line">	<span class="built_in">free</span>(L.elem); <span class="comment">//释放存储空间</span></span><br><span class="line">	L.length = <span class="number">0</span>;</span><br><span class="line">	L.listsize = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//	free(&amp;L);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重点释放顺序表的存储单元。如果顺序表自身的内存也是动态分配的，需要手动释放。</p>
</blockquote>
<p>最后附上，头文件的定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sqlist.h</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 线性表的顺序存储</span></span><br><span class="line"><span class="comment"> *  Created on: 2016年8月30日</span></span><br><span class="line"><span class="comment"> *      Author: flueky</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SQLIST_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLIST_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INIT_SIZE 50</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTINCREMENT 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SeqType; <span class="comment">//存储单元类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	SeqType *elem; <span class="comment">//存储空间基地址</span></span><br><span class="line">	<span class="type">int</span> length; <span class="comment">//当前长度</span></span><br><span class="line">	<span class="type">int</span> listsize; <span class="comment">//当前分配的存储容量（以sizeof(ElemType)为单位）</span></span><br><span class="line">&#125; SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建顺序表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SqList <span class="title function_">createList_sq</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化顺序表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">initList_sq</span><span class="params">(SqList &amp;)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入顺序表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertList_sq</span><span class="params">(SqList &amp;,<span class="type">int</span> index,SeqType)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入顺序表（结尾的位置）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertList_sq</span><span class="params">(SqList &amp;,SeqType)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在顺序表中移除指定位置元素，下标从0开始</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">removeList_sq</span><span class="params">(SqList &amp;,<span class="type">int</span>,SeqType &amp;)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在顺序表中删除指定元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">removeList_sq</span><span class="params">(SqList &amp;,SeqType)</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 销毁顺序表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destoryList_sq</span><span class="params">(SqList &amp;)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* SQLIST_H_ */</span></span></span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/test/221/">Activity&amp;Fragment生命周期详解</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-06-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/Android/">Android</a></span><div class="content"><p>生命周期，是初学Android必须要掌握的一个知识点，也是面试时最常问的知识点。最近突然发现，公司架构中关于fragment使用的代码还不够完美。因此先决定先巩固一遍Fragment生命周期，连带着Activity生命周期（<strong>两者之间还是有很大的关联</strong>），再尝试改善现有代码。关于生命周期的概念，个人觉得，设计Android的工程师们，很大程度上参考了IOS。</p></div><a class="more" href="/test/221/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/test/220/">指针与引用</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-05-27</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/C-C/">C/C++</a></span><div class="content"><p>初学者分析指针和引用最常用的方式是写一个swap函数，分析传值还是传址的交换。</p>
<h1 id="普通变量交换"><a href="#普通变量交换" class="headerlink" title="普通变量交换"></a>普通变量交换</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n&quot;</span>,a,b);</span><br><span class="line">	</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n&quot;</span>,a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出</p>
<blockquote>
<p>交换前:1 2 <br/><br>交换后:2 1 <br/></p>
</blockquote>
<p>这里没什么好分析的。</p>
<h1 id="指针交换"><a href="#指针交换" class="headerlink" title="指针交换"></a>指针交换</h1><p>正确交换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>* p = &amp;a;</span><br><span class="line">    <span class="type">int</span>* q = &amp;b;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n\n&quot;</span>,*p,*q);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>* temp = p;</span><br><span class="line">    p = q;</span><br><span class="line">    q = temp;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n&quot;</span>,*p,*q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>交换前:1 2 <br/><br>交换前:1 2 <br/></p>
<p>交换后:1 2 <br/><br>交换后:2 1 <br/></p>
</blockquote>
<p>现在就变得有意思了。最初p、q分别指向a和b的地址。表示p-&gt;a,q-&gt;b。经过交换之后，p-&gt;b,q-&gt;a。</p>
<p>错误交换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>* p = &amp;a;</span><br><span class="line">    <span class="type">int</span>* q = &amp;b;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n\n&quot;</span>,*p,*q);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>* temp = p;</span><br><span class="line">    *p = *q;<span class="comment">//注意这里的不同</span></span><br><span class="line">    q = temp;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n&quot;</span>,*p,*q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>交换前:1 2 <br/><br>交换前:1 2 <br/></p>
</blockquote>
<blockquote>
<p>交换后:2 2 <br/><br>交换后:2 2 <br/></p>
</blockquote>
<p>代码<code>*p = *q</code>等价于<code>a=b</code>。所以第一个会输出2 2。需要注意的是，此时p 和 q 依然指向不同的地址。执行完代码<code>q = temp</code> q 和p 指向相同的地址了。因为最初<code>temp = p</code>。</p>
<p>也有的人写成这样的交换方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//案例1</span></span><br><span class="line"><span class="type">int</span> temp = *p;</span><br><span class="line">   *p = *q;</span><br><span class="line">   *q = temp;</span><br><span class="line"><span class="comment">//案例2</span></span><br><span class="line">   <span class="type">int</span> temp = *p;</span><br><span class="line">   p = q;</span><br><span class="line">   *q = temp;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>案例1 <br/><br>交换后:2 1 <br/><br>交换后:2 1 <br/></p>
</blockquote>
<blockquote>
<p>案例2 有<code>*q = temp</code> <br/><br>交换后:1 1 <br/><br>交换后:1 1 <br/></p>
</blockquote>
<blockquote>
<p>案例2 没有<code>*q = temp</code> <br/><br>交换后:1 2 <br/><br>交换后:2 2 <br/></p>
</blockquote>
<p>关于案例1，等价于普通变量的交换。最终交换的是a 和 b的值。p和q的指针不变。案例2中，先给temp赋a 的值，再将p的指针指向q，最后修改q指向的值。得出最终结果p &#x3D; q-&gt;b &#x3D; a &#x3D; 1。如果没有	<code>*q = temp</code>最终结果p &#x3D; q-&gt;b &#x3D; 2，a &#x3D; 1</p>
<h1 id="二重指针交换"><a href="#二重指针交换" class="headerlink" title="二重指针交换"></a>二重指针交换</h1><p>正常交换</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>* p = &amp;a;</span><br><span class="line">    <span class="type">int</span>* q = &amp;b;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>** pp = &amp;p;</span><br><span class="line">    <span class="type">int</span>** qq = &amp;q;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n&quot;</span>,*p,*q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n\n&quot;</span>,**pp,**qq);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>** temp = pp;</span><br><span class="line">    pp = qq;</span><br><span class="line">    qq = temp;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n&quot;</span>,*p,*q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n&quot;</span>,**pp,**qq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>交换前:1 2 <br/><br>交换前:1 2 <br/><br>交换前:1 2 <br/></p>
</blockquote>
<blockquote>
<p>交换后:1 2 <br/><br>交换后:1 2 <br/><br>交换后:2 1 <br/></p>
</blockquote>
<p>简单分析：最初时，pp-&gt;p-&gt;a,qq-&gt;q-&gt;b。交换后：qq-&gt;p-&gt;a,pp-&gt;q-&gt;b。弄懂了二重指针的道理，之后遇到三重、四重指针时，可以递归分析。</p>
<p>错误交换</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>* p = &amp;a;</span><br><span class="line">    <span class="type">int</span>* q = &amp;b;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>** pp = &amp;p;</span><br><span class="line">    <span class="type">int</span>** qq = &amp;q;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n&quot;</span>,*p,*q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n\n&quot;</span>,**pp,**qq);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>** temp = pp;</span><br><span class="line">    **pp = **qq;<span class="comment">//注意此处的不同</span></span><br><span class="line">    qq = temp;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n&quot;</span>,*p,*q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n&quot;</span>,**pp,**qq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>交换后:2 2 <br/><br>交换后:2 2 <br/><br>交换后:2 2 <br/></p>
</blockquote>
<p>之前也说过了，此处<code>**pp = **qq</code>相当于<code>a = b</code>所以pp-&gt;p-&gt;a &#x3D; 2；qq-&gt;q-&gt;b &#x3D; 2;因此输出全是2。执行<code>qq = temp</code>使得qq&#x3D;pp-&gt;p-&gt;a &#x3D; 2，并没有改变q-&gt;b &#x3D; 2。</p>
<p>看到这里有没有晕？接下来举几个一定能让你晕的案例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//案例1</span></span><br><span class="line">   <span class="type">int</span>** temp = pp;</span><br><span class="line">   *pp = *qq;</span><br><span class="line">   qq = temp;</span><br><span class="line"><span class="comment">//案例2</span></span><br><span class="line">   <span class="type">int</span>* temp = *pp;</span><br><span class="line">   **pp = **qq;</span><br><span class="line">   *qq = temp;</span><br><span class="line"><span class="comment">//案例3</span></span><br><span class="line"><span class="type">int</span>* temp = *pp;</span><br><span class="line">   *pp = *qq;</span><br><span class="line">   *qq = temp;</span><br><span class="line"><span class="comment">//案例4</span></span><br><span class="line"><span class="type">int</span>* temp = *pp;</span><br><span class="line">   pp = qq;</span><br><span class="line">   *qq = temp;</span><br><span class="line"><span class="comment">//案例5</span></span><br><span class="line">   <span class="type">int</span> temp = **pp;</span><br><span class="line">   pp = qq;</span><br><span class="line">   **qq = temp;</span><br><span class="line">	<span class="comment">//案例6   </span></span><br><span class="line">   <span class="type">int</span> temp = **pp;</span><br><span class="line">   *pp = *qq;</span><br><span class="line">   **qq = temp;</span><br><span class="line"><span class="comment">//案例7</span></span><br><span class="line">   <span class="type">int</span> temp = **pp;</span><br><span class="line">   **pp = **qq;</span><br><span class="line">   **qq = temp;</span><br></pre></td></tr></table></figure>

<p>加上之前的两个，这里包含了二重指针置换的所有的可能的写法。</p>
<blockquote>
<p>案例1 <br/><br>交换后:1 2 <br/><br>交换后:2 2 <br/><br>交换后:2 2 <br/></p>
</blockquote>
<p>执行<code>*pp = *qq</code>，pp-&gt;p&#x3D;q-&gt;b&#x3D;2,qq-&gt;q-&gt;b&#x3D;2。执行<code>qq = temp</code>，qq&#x3D;pp-&gt;p&#x3D;q-&gt;b&#x3D;2。而此时a&#x3D;1，b&#x3D;2不变。</p>
<blockquote>
<p>案例2 <br/><br>交换后:2 2 <br/><br>交换后:2 2 <br/><br>交换后:2 2 <br/></p>
</blockquote>
<p>执行<code>**pp = **qq</code>，pp-&gt;p-&gt;a&#x3D;b&#x3D;2,qq-&gt;q-&gt;b&#x3D;2。执行	<code>*qq = temp</code>，pp-&gt;p-&gt;a&#x3D;b&#x3D;2,qq-&gt;q&#x3D;p-&gt;a&#x3D;2。<strong>分析这里时，可将<code>**pp = **qq</code>等价成<code>a = b</code>而<code>*qq = temp</code>等价成q &#x3D; temp &#x3D; p</strong>。</p>
<blockquote>
<p>案例3 <br/><br>交换后:1 2 <br/><br>交换后:2 1 <br/><br>交换后:2 1 <br/></p>
</blockquote>
<p>用通俗的话讲，这里交换的是p和q 两个指针（等价于一重指针的正确案例）。pp-&gt;p-&gt;b &#x3D; 2,qq-&gt;q-&gt;a &#x3D; 1;</p>
<blockquote>
<p>案例4 <br/><br>交换后:1 2 <br/><br>交换后:1 1 <br/><br>交换后:1 1 <br/></p>
</blockquote>
<p>执行<code>pp = qq</code>，pp&#x3D;qq-&gt;q-&gt;b&#x3D;2,p-&gt;a&#x3D;1。执行<code> *qq = temp</code>,等价于<code>q = p</code>,所以pp&#x3D;qq-&gt;q&#x3D;p-&gt;a&#x3D;1，b&#x3D;2。</p>
<blockquote>
<p>案例5 <br/><br>交换后:1 1 <br/><br>交换后:1 1 <br/><br>交换后:1 1 <br/></p>
</blockquote>
<p>执行<code>pp = qq</code>,pp&#x3D;qq-&gt;q-&gt;b&#x3D;2,p-&gt;a&#x3D;1。执行<code>**qq = temp</code>等价于<code>**qq = **pp，b = a</code>，因此pp&#x3D;qq-&gt;q-&gt;b&#x3D;a &#x3D; 1,p-&gt;a&#x3D;1</p>
<blockquote>
<p>案例6 <br/><br>交换后:1 1 <br/><br>交换后:1 1 <br/><br>交换后:1 1 <br/></p>
</blockquote>
<p>执行<code>*pp = *qq</code>，等价于<code>p = q</code>，pp-&gt;p&#x3D;q-&gt;b&#x3D;2,qq-&gt;q-&gt;b&#x3D;2,a&#x3D;1。执行<code>**qq = temp</code>，pp-&gt;p&#x3D;q-&gt;b&#x3D;a&#x3D;1,qq-&gt;q-&gt;b&#x3D;a&#x3D;1。</p>
<blockquote>
<p>案例7 <br/><br>交换后:2 1 <br/><br>交换后:2 1 <br/><br>交换后:2 1 <br/></p>
</blockquote>
<p>一句话的总结就是：交换了a和b。pp-&gt;p-&gt;a &#x3D; 2,qq-&gt;q-&gt;b &#x3D; 1。</p>
<h1 id="引用交换"><a href="#引用交换" class="headerlink" title="引用交换"></a>引用交换</h1><p>引用是C++中才有的概念，因此在c文件中测试如下代码，会在编译时候产生语法错误。需要创建cpp文件测试。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>&amp; r = a;</span><br><span class="line">    <span class="type">int</span>&amp; s = b;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n\n&quot;</span>,r,s);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>&amp; temp = r;</span><br><span class="line">    r = s;</span><br><span class="line">    s = temp;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n&quot;</span>,r,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>交换前:1 2 <br/><br>交换前:1 2 <br/></p>
<p>交换后:2 2 <br/><br>交换后:2 2 <br/></p>
</blockquote>
<p>运行后发现，这里并没有起到交换的作用。究其原因，定义temp 引用时，temp 和 r指向内存中同一块，也就是a所在的内存。引用之间只能够传值（指针之间可以传止，如p &#x3D; q使 p&#x3D;q-&gt;b&#x3D;2，a&#x3D;1），r &#x3D; s &#x3D; b &#x3D; 2，于是temp &#x3D; 2，a &#x3D; 2。s &#x3D; temp &#x3D; 2。</p>
<p>正确的交换应当是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> temp = r;<span class="comment">//注意这里的不同</span></span><br><span class="line">r = s;</span><br><span class="line">s = temp;</span><br></pre></td></tr></table></figure>

<p>这样就得到了预期的运行结果。啊哦……</p>
<blockquote>
<p>交换前:1 2 <br/><br>交换前:1 2 <br/></p>
<p>交换后:2 1 <br/><br>交换后:2 1 <br/></p>
</blockquote>
<h1 id="函数交换"><a href="#函数交换" class="headerlink" title="函数交换"></a>函数交换</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通交换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">swap</span>(a, b);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n\n&quot;</span>,a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n&quot;</span>,a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>交换前:1 2 <br/></p>
<p>交换后:1 2 <br/></p>
</blockquote>
<p>swap 函数中的a、b是形参，main函数中，传入的是a、b 的值，所以在swap函数中交换的是形参a、b的值，不影响main函数中a、b的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指针交换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapP</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span>* p = &amp;a;</span><br><span class="line">    <span class="type">int</span>* q = &amp;b;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n\n&quot;</span>,*p,*q);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">swapP</span>(&amp;a, &amp;b);</span><br><span class="line"><span class="comment">//    swapP(p, q);//等价上句</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n\n&quot;</span>,*p,*q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>交换前:1 2 <br/><br>交换前:1 2 <br/></p>
<p>交换后:2 1 <br/><br>交换后:2 1 <br/></p>
</blockquote>
<p>swapP函数两个参数都是指针类型，接收main函数中的指针p或a的地址（<strong>指针p 指向a的地址，同理b</strong>），因此在swap中交换的依然是a和b的值，不改变main函数中p-&gt;a,q-&gt;b。</p>
<p>错误交换示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指针交换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapP</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span>* temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>交换前:1 2 <br/><br>交换前:1 2 <br/></p>
<p>交换后:1 2 <br/><br>交换后:1 2 <br/></p>
</blockquote>
<p>这里是对指针指向的地址进行交换，而这里的指针依然是形参，交换后的值不改变main函数中的p、q。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二重指针交换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapPP</span><span class="params">(<span class="type">int</span>** pp,<span class="type">int</span> **qq)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span>* temp = *pp;</span><br><span class="line">    *pp = *qq;</span><br><span class="line">    *qq = temp;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span>* p = &amp;a;</span><br><span class="line">    <span class="type">int</span>* q = &amp;b;</span><br><span class="line">    <span class="type">int</span>** pp = &amp;p;</span><br><span class="line">    <span class="type">int</span>** qq = &amp;q;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n&quot;</span>,*p,*q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n\n&quot;</span>,**pp,**qq);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">swapPP</span>(pp, qq);</span><br><span class="line"><span class="comment">//    swapPP(&amp;p, &amp;q);//等价上句</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n&quot;</span>,*p,*q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n\n&quot;</span>,**pp,**qq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>交换前:1 2 <br/><br>交换前:1 2 <br/><br>交换前:1 2 <br/></p>
<p>交换后:1 2 <br/><br>交换后:2 1 <br/><br>交换后:2 1 <br/></p>
</blockquote>
<blockquote>
<p>交换前：pp-&gt;p-&gt;a &#x3D; 1,qq-&gt;q-&gt;b &#x3D; 2;<br>交换后：pp-&gt;p-&gt;b &#x3D; 2,qq-&gt;q-&gt;a &#x3D; 1;换句话说，交换了p和q指向的地址。</p>
</blockquote>
<p>错误交换示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二重指针交换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapPP1</span><span class="params">(<span class="type">int</span>** pp,<span class="type">int</span> **qq)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span>** temp = pp;</span><br><span class="line">    pp = qq;</span><br><span class="line">    qq = temp;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>交换前:1 2 <br/><br>交换前:1 2 <br/><br>交换前:1 2 <br/></p>
<p>交换后:1 2 <br/><br>交换后:1 2 <br/><br>交换后:1 2 <br/></p>
</blockquote>
<p>原理同一重指针的错误交换示例。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 引用交换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapR</span><span class="params">(<span class="type">int</span>&amp; a,<span class="type">int</span>&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>&amp; r = a;</span><br><span class="line">    <span class="type">int</span>&amp; s = b;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前:%d %d\n\n&quot;</span>,r,s);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">swapR</span>(r,s);</span><br><span class="line"><span class="comment">//    swapR(a,b);//等价上句</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后:%d %d\n&quot;</span>,r,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>交换前:1 2 <br/><br>交换前:1 2 <br/></p>
<p>交换后:2 1 <br/><br>交换后:2 1 <br/></p>
</blockquote>
<p>原理同一重指针的正确交换。这里传入的是a、b的地址。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>正确的交换代码片段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* temp = p;</span><br><span class="line">p = q;</span><br><span class="line">q = temp;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>** temp = pp;</span><br><span class="line">pp = qq;</span><br><span class="line">qq = temp;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* temp = *pp;</span><br><span class="line">*pp = *qq;</span><br><span class="line">*qq = temp;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> temp = r;</span><br><span class="line">r = s;</span><br><span class="line">s = temp;</span><br></pre></td></tr></table></figure>

<p><strong>注意二重指针的两种交换，在函数中只有一种是有效的</strong></p>
<p><strong>谨以此篇博文，欢迎加入我们软件实验室的新生……</strong></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/test/219s/">分分钟修改Android keystore</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-05-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/Android/">Android</a></span><div class="content"><p>之前写过一篇博客[Android开发必备技能——修改debug签名](&#x2F;blog&#x2F;2016-05-04&#x2F;)，感觉对不习惯使用Linux命令的小伙伴而言，简直是噩梦。因此奉上简单实用的Java代码。</p></div><a class="more" href="/test/219s/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/test/218/">Android开发必备技能——修改debug签名</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-05-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a></span><div class="content"><p>从事Android开发的小伙伴们，想必都会遇到这样的问题。当你的应用中需要集成百度地图、极光推送等第三方平台时，会去申请一个叫做AppKey的东西。与此同时，你得提供下应用签名信息的MD5或SHA1。然后就悲催的发现，只有用指定的签名文件打包时，该功能才能正常使用。如果你用的是开发工具的debug keystore签名信息，直接run一下就好，如果你用的是APP发布时候的keystore，每次测试时都得export 一个apk。心中一万只草泥马在奔腾的有木有？</p></div><a class="more" href="/test/218/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/test/217/">JSON格式数据解析（Java版）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-05-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/Java/">Java</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/test/tags/Json/">Json</a></span><div class="content"><p><code>JSON</code>(JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于ECMAScript的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C、C++、C#、Java、JavaScript、Perl、Python等）。这些特性使JSON成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成(一般用于提升网络传输速率)。</p></div><a class="more" href="/test/217/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/test/216/">C++高级编程（一）——运算符重载</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-05-02</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/C-C/">C/C++</a></span><div class="content"><p>C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为<strong>函数重载</strong>和<strong>运算符重载</strong>。</p>
<p>重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。</p>
<p>当您调用一个重载函数或重载运算符时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为<strong>重载决策</strong>。</p></div><a class="more" href="/test/216/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/test/215/">C++面向对象（三）——封装和多态</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-04-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/test/categories/C-C/">C/C++</a></span><div class="content"><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><h2 id="什么是封装"><a href="#什么是封装" class="headerlink" title="什么是封装"></a>什么是封装</h2><p>封装(encapsulation)又叫隐藏实现(Hiding the implementation)。就是只公开代码单元的对外接口，而隐藏其具体实现。</p>
<h2 id="实现封装"><a href="#实现封装" class="headerlink" title="实现封装"></a>实现封装</h2><p>在程序设计里，封装往往是通过访问控制实现的。C++，Java，Objective-C中都有 Public, Protected, Private 等访问控制符。通过用Public将信息暴露，Private，Protected将信息隐藏，来实现封装。</p>
<p>一个优秀的OOP程序员会尽量不对外公开代码，即最喜欢用Private关键字。因为在OOP中，对代码访问控制得越严格，日后你对代码修改的自由就越大。</p>
<h2 id="封装的好处"><a href="#封装的好处" class="headerlink" title="封装的好处"></a>封装的好处</h2><ol>
<li>封装使得对代码的修改更加安全和容易。将代码分成了一个个相对独立的单元。 </li>
<li>封装使整个软件开发复杂度大大降低。 </li>
<li>封装还避免了命名冲突的问题。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义动物类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">		string species;<span class="comment">//物种</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">string <span class="title">getSpecies</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Animal::getSpecies</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> species;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哺乳动物继承动物类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BreastfeedAnimal</span>:<span class="keyword">public</span> Animal&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">time_t</span> birthday;<span class="comment">//生日</span></span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">		string type;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">BreastfeedAnimal</span>(string spec);</span><br><span class="line">		~<span class="built_in">BreastfeedAnimal</span>();</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BreastfeedAnimal::<span class="built_in">BreastfeedAnimal</span>(string spec)&#123;</span><br><span class="line">	species = spec;</span><br><span class="line">	birthday = <span class="built_in">time</span>(<span class="number">0</span>);<span class="comment">//生成构造函数时，生成出生日期</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BreastfeedAnimal::~<span class="built_in">BreastfeedAnimal</span>()&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BreastfeedAnimal::getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">time</span>(<span class="number">0</span>)-birthday;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义陆生生物</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LandAnimal</span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义羊，继承自哺乳动物和陆生生物</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> :<span class="keyword">public</span> BreastfeedAnimal,<span class="keyword">public</span> LandAnimal&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Sheep</span>();</span><br><span class="line">		~<span class="built_in">Sheep</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果父类显示定义构造方法，子类构造方法必须调用父类构造方法</span></span><br><span class="line">Sheep::<span class="built_in">Sheep</span>():<span class="built_in">BreastfeedAnimal</span>(<span class="string">&quot;sheep&quot;</span>)&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">Sheep::~<span class="built_in">Sheep</span>()&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="comment">//	Animal* sheep = new BreastfeedAnimal(&quot;sheep&quot;);</span></span><br><span class="line">	Sheep* sheep = <span class="keyword">new</span> <span class="built_in">Sheep</span>();</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;the animal&#x27;s species is &quot;</span>&lt;&lt;sheep-&gt;<span class="built_in">getSpecies</span>()&lt;&lt;endl;</span><br><span class="line">	<span class="comment">//生成一个耗时操作，阻塞程序运行</span></span><br><span class="line">	<span class="type">int</span> i=<span class="number">999999999</span>;</span><br><span class="line">	<span class="keyword">while</span>(i--&gt;<span class="number">0</span>);</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;the animal&#x27;s age is &quot;</span>&lt;&lt;sheep-&gt;<span class="built_in">getAge</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>定义哺乳动物类<code>BreastfeedAnimal</code>,它有物种名称和出生日期两个属性。由于这两个属性在生成对象之后是不可以改变的，所以需要用private隐藏起来。与此同时，获取该对象的年龄，只需要用当前时间减去生成这个对象的时间。换句话来说，获取对象的年龄也只是个只读权限，同时也是不可修改的。这就是封装的简单用途。</p>
</blockquote>
<h2 id="设计策略"><a href="#设计策略" class="headerlink" title="设计策略"></a>设计策略</h2><p>通常情况下，我们都会设置类成员状态为私有（private），除非我们真的需要将其暴露，这样才能保证良好的封装性。</p>
<p>这通常应用于数据成员，但它同样适用于所有成员，包括虚函数。</p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义动物类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">		string species;<span class="comment">//物种</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">string <span class="title">getSpecies</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Animal::getSpecies</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;animal species&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> species;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哺乳动物继承动物类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BreastfeedAnimal</span>:<span class="keyword">public</span> Animal&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">time_t</span> birthday;<span class="comment">//生日</span></span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">		string type;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">BreastfeedAnimal</span>(string spec);</span><br><span class="line">		~<span class="built_in">BreastfeedAnimal</span>();</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BreastfeedAnimal::<span class="built_in">BreastfeedAnimal</span>(string spec)&#123;</span><br><span class="line">	species = spec;</span><br><span class="line">	birthday = <span class="built_in">time</span>(<span class="number">0</span>);<span class="comment">//生成构造函数时，生成出生日期</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BreastfeedAnimal::~<span class="built_in">BreastfeedAnimal</span>()&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BreastfeedAnimal::getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">time</span>(<span class="number">0</span>)-birthday;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义陆生生物</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LandAnimal</span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义羊，继承自哺乳动物和陆生生物</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> :<span class="keyword">public</span> BreastfeedAnimal,<span class="keyword">public</span> LandAnimal&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Sheep</span>();</span><br><span class="line">		~<span class="built_in">Sheep</span>();</span><br><span class="line">		<span class="function">string <span class="title">getSpecies</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果父类显示定义构造方法，子类构造方法必须调用父类构造方法</span></span><br><span class="line">Sheep::<span class="built_in">Sheep</span>():<span class="built_in">BreastfeedAnimal</span>(<span class="string">&quot;sheep&quot;</span>)&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">Sheep::~<span class="built_in">Sheep</span>()&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Sheep::getSpecies</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;sheep species&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> species;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义牛</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ox</span>:<span class="keyword">public</span> BreastfeedAnimal,<span class="keyword">public</span> LandAnimal&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Ox</span>();</span><br><span class="line">		~<span class="built_in">Ox</span>();		</span><br><span class="line">		<span class="function">string <span class="title">getSpecies</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Ox::<span class="built_in">Ox</span>():<span class="built_in">BreastfeedAnimal</span>(<span class="string">&quot;ox&quot;</span>)&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Ox::~<span class="built_in">Ox</span>()&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Ox::getSpecies</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;ox species&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> species;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	Animal sheep;</span><br><span class="line">	Animal ox;</span><br><span class="line">	</span><br><span class="line">	sheep.<span class="built_in">getSpecies</span>();</span><br><span class="line">	ox.<span class="built_in">getSpecies</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<pre><code>animal species
animal species
</code></pre>
<blockquote>
<p>并没有达到期望中预想的值。有人说将sheep 和ox<strong>强制类型转换</strong>（以下简称：强转）成Sheep 和Ox 对象，事实上编译器会报错。<strong>怎样做，编译器才能够正确强转</strong>？而怎样做，才能正确调用sheep和ox的<code>getSpecies()</code>函数？</p>
</blockquote>
<p>修改main函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	Animal* sheep = <span class="keyword">new</span> <span class="built_in">Sheep</span>();</span><br><span class="line">	Animal ox;</span><br><span class="line">	</span><br><span class="line">	sheep-&gt;<span class="built_in">getSpecies</span>();</span><br><span class="line">	ox.<span class="built_in">getSpecies</span>();</span><br><span class="line">	</span><br><span class="line"><span class="comment">//	((Ox)ox).getSpecies();//这种强转会报错</span></span><br><span class="line">	((Sheep *)sheep)-&gt;<span class="built_in">getSpecies</span>();<span class="comment">//强转通过</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">delete</span> sheep;</span><br><span class="line"><span class="comment">//	delete ((Sheep *)sheep)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>Animal 构造函数
Sheep 构造函数
Animal 构造函数
animal species
animal species
sheep species
Animal 析构函数
Animal 析构函数
</code></pre>
<blockquote>
<p>程序中分别用两种方式声明sheep和ox对象。分析前三行，sheep是Sheep类的对象，因此会先调用基类（Animal类）的构造函数，再调用Sheep类的构造函数。ox是Animal类的对象，所以只调用Animal类的构造函数。分析第六行，正确强转之后就会调用Sheep类的<code>getSpecies()</code>函数。分析最后两行，ox是编译器释放资源时调用的，此处只调用Animal的析构函数。sheep 是delete之后，调用析构函数。预期情况是先调用Sheep类的析构函数再调用Animal类的析构函数。然而，此处sheep 是Animal类的实例，所以只调用Animal类的析构函数。修改main函数如下，自行分析输出。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	Sheep* sheep = <span class="keyword">new</span> <span class="built_in">Sheep</span>();</span><br><span class="line">	Ox ox;</span><br><span class="line">	</span><br><span class="line">	sheep-&gt;<span class="built_in">getSpecies</span>();</span><br><span class="line">	ox.<span class="built_in">getSpecies</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">delete</span> sheep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>Animal 构造函数
Sheep 构造函数
Animal 构造函数
Ox 构造函数
sheep species
ox species
Sheep 析构函数
Animal 析构函数
Ox 析构函数
Animal 析构函数
</code></pre>
<p>再回到上一个问题：<strong>而怎样做，才能正确调用sheep和ox的<code>getSpecies()</code>函数</strong>？这里引入两个概念：<strong>静态多态</strong>和<strong>虚函数</strong></p>
<p><strong>静态多态</strong>或静态链接是指函数调用在程序执行前就准备好了。有时候这也被称为<strong>早绑定</strong>，因为 <code>getSpecies()</code>函数在程序编译期间就已经设置好了。出问题的原因是被设置为基类的版本。</p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p><strong>虚函数</strong>是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。</p>
<p>我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为<strong>动态链接</strong>或后期绑定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义动物类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">		string species;<span class="comment">//物种</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Animal</span>();</span><br><span class="line">		~<span class="built_in">Animal</span>();</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> string <span class="title">getSpecies</span><span class="params">()</span></span>;<span class="comment">//定义为虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	Animal* sheep = <span class="keyword">new</span> <span class="built_in">Sheep</span>();</span><br><span class="line">	Animal ox;</span><br><span class="line">	</span><br><span class="line">	sheep-&gt;<span class="built_in">getSpecies</span>();</span><br><span class="line">	ox.<span class="built_in">getSpecies</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">delete</span> sheep;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<pre><code>Animal 构造函数
Sheep 构造函数
Animal 构造函数
sheep species
animal species
Animal 析构函数
Animal 析构函数
</code></pre>
<blockquote>
<p>分析输出，sheep已经正确调用了Sheep类中的 <code>getSpecies()</code>，而ox仍然调用Animal中的 <code>getSpecies()</code>函数。之前已经提到，ox是Animal的对象，自然只能调用Animal的函数。</p>
</blockquote>
<h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p>纯虚函数是一种特殊的虚函数，在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。</p>
<p>纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。凡是含有纯虚函数的类叫做抽象类。这种类不能声明对象，只是作为基类为派生类服务。除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。</p>
<p>一般而言<strong>纯虚函数</strong>的函数体是缺省的，但是也可以给出纯虚函数的函数体（此时纯虚函数变为虚函数），这一点经常被人们忽视，调用纯虚函数的方法为baseclass::virtual function。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义动物类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">		string species;<span class="comment">//物种</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Animal</span>();</span><br><span class="line">		~<span class="built_in">Animal</span>();</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> string <span class="title">getSpecies</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//纯虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>&#x3D; 0告诉编译器，函数没有主体，所以<code>getSpecies()</code>就是纯虚函数，Animal类因此也成为了抽象类。学过Java的也许会联想到抽象类和接口中才有的抽象函数。</p>
</blockquote>
<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>设计抽象类的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。</p>
<p>因此，如果一个抽象类的子类需要被实例化，则必须实现每个虚函数，这也意味着 C++ 支持使用抽象类声明接口。如果没有在派生类中重载纯虚函数，就尝试实例化该类的对象，会导致编译错误。</p>
<p>子类没有实现抽象父类中的函数，则子类也是抽象类，该子类不能实例化对象。可用于实例化对象的类被称为具体类。</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/test/page/4/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/test/">1</a><span class="space">&hellip;</span><a class="page-number" href="/test/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/test/page/6/">6</a><a class="page-number" href="/test/page/7/">7</a><a class="extend next" rel="next" href="/test/page/6/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2016 - 2024 By flueky</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/test/js/utils.js?version=1.9.1"></script><script src="/test/js/fancybox.js?version=1.9.1"></script><script src="/test/js/sidebar.js?version=1.9.1"></script><script src="/test/js/copy.js?version=1.9.1"></script><script src="/test/js/fireworks.js?version=1.9.1"></script><script src="/test/js/transition.js?version=1.9.1"></script><script src="/test/js/scroll.js?version=1.9.1"></script><script src="/test/js/head.js?version=1.9.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>