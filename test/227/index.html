<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="数据结构（五）——二叉树（C语言实现）"><meta name="keywords" content="二叉树"><meta name="author" content="flueky"><meta name="copyright" content="flueky"><title>数据结构（五）——二叉树（C语言实现） | Flueky 技术小站</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">定义结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.</span> <span class="toc-text">定义操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E7%A9%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.2.1.</span> <span class="toc-text">构造空二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.2.2.</span> <span class="toc-text">创建二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.2.3.</span> <span class="toc-text">递归先序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.2.4.</span> <span class="toc-text">递归中序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.2.5.</span> <span class="toc-text">递归后序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.2.6.</span> <span class="toc-text">非递归先序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.2.7.</span> <span class="toc-text">非递归中序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.2.8.</span> <span class="toc-text">非递归后序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-number">2.2.9.</span> <span class="toc-text">层次遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E7%BB%93%E7%82%B9"><span class="toc-number">2.2.10.</span> <span class="toc-text">访问结点</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">flueky</div><div class="author-info__description text-center">小飞哥的个人博客主页</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">71</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">32</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">13</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Flueky 技术小站</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right"></span></div><div id="post-info"><div id="post-title">数据结构（五）——二叉树（C语言实现）</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-10-18</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/C-C/">C/C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>之前四篇博客分别介绍了线性结构中的[顺序表](&#x2F;222)、[链表](&#x2F;223)、[栈](&#x2F;225)、[队列](&#x2F;226)。从难度来讲，顺序表到链表是递增的。从实现来讲，栈和队列基于顺序表和链表（<strong>之前栈采用了顺序表的存储结构，队列采用了链表的存储结构</strong>）。此次介绍的二叉树虽是非线性结构的树形结构分支，但在其各个结点遍历的实现上，使用到了栈和队列的特性。</p>
<p><strong>二叉树</strong>是一种特殊的线性结构，每个结点最多只有两个分支，称左孩子结点和右孩子结点。更多关于二叉树的特性，自行查阅资料。接下来只详细的介绍创建二叉树以及二叉树的遍历。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="定义结构"><a href="#定义结构" class="headerlink" title="定义结构"></a>定义结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> TreeType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BitNode</span> &#123;</span><br><span class="line">	TreeType key;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BitNode</span> *left;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BitNode</span> *right;</span><br><span class="line">&#125; BitTree;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>二叉树的结构和双向链表的结构一致，只是双向链表的两个指针构成线性结构，二叉树的两个指针构成非线性结构。</p>
</blockquote>
<h2 id="定义操作"><a href="#定义操作" class="headerlink" title="定义操作"></a>定义操作</h2><h3 id="构造空二叉树"><a href="#构造空二叉树" class="headerlink" title="构造空二叉树"></a>构造空二叉树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造空二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initBitTree</span><span class="params">(BitTree&amp; root)</span> </span>&#123;</span><br><span class="line">	root.left = <span class="literal">NULL</span>;</span><br><span class="line">	root.right = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将根结点的左右两个指针置空。</p>
</blockquote>
<h3 id="创建二叉树"><a href="#创建二叉树" class="headerlink" title="创建二叉树"></a>创建二叉树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建二叉树(按照前序遍历方式构建二叉树)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createBitTree</span><span class="params">(BitTree** parent)</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span> key = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">if</span> (key == <span class="string">&#x27;#&#x27;</span>) &#123; <span class="comment">//输入#表示该节点是叶子节点</span></span><br><span class="line">		*parent = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		*parent = (BitTree*) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BitTree));</span><br><span class="line">		<span class="keyword">if</span> (*parent == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">9</span>);</span><br><span class="line">		(*parent)-&gt;key = key;</span><br><span class="line">		<span class="built_in">createBitTree</span>(&amp;((*parent)-&gt;left));</span><br><span class="line">		<span class="built_in">createBitTree</span>(&amp;((*parent)-&gt;right));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>先序遍历的方式构建二叉树，输入#号表示当前结点的左孩子结点或右孩子结点为空。</p>
</blockquote>
<h3 id="递归先序遍历"><a href="#递归先序遍历" class="headerlink" title="递归先序遍历"></a>递归先序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归先序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrderTraverse</span><span class="params">(BitTree* parent)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (parent != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">visit</span>(*parent);</span><br><span class="line">		<span class="built_in">preOrderTraverse</span>(parent-&gt;left);<span class="comment">//遍历左子树</span></span><br><span class="line">		<span class="built_in">preOrderTraverse</span>(parent-&gt;right);<span class="comment">//遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>先访问根结点，再依次递归访问左子树和右子树</p>
</blockquote>
<h3 id="递归中序遍历"><a href="#递归中序遍历" class="headerlink" title="递归中序遍历"></a>递归中序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归中序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderTraverse</span><span class="params">(BitTree* parent)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (parent != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">inOrderTraverse</span>(parent-&gt;left);<span class="comment">//遍历左子树</span></span><br><span class="line">		<span class="built_in">visit</span>(*parent);</span><br><span class="line">		<span class="built_in">inOrderTraverse</span>(parent-&gt;right);<span class="comment">//遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>先递归遍历左子树，再访问根节点，最后递归访问右子树。</p>
</blockquote>
<h3 id="递归后序遍历"><a href="#递归后序遍历" class="headerlink" title="递归后序遍历"></a>递归后序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归后序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrderTraverse</span><span class="params">(BitTree* parent)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (parent != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">postOrderTraverse</span>(parent-&gt;left);<span class="comment">//遍历左子树</span></span><br><span class="line">		<span class="built_in">postOrderTraverse</span>(parent-&gt;right);<span class="comment">//遍历右子树</span></span><br><span class="line">		<span class="built_in">visit</span>(*parent);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>先依次递归访问左子树和右子树，最后访问根结点。</p>
</blockquote>
<p>*<strong>三序遍历的递归方式简单的介绍到这里，三序遍历的非递归方式一个比一个难，这是本人自行思考写出的算法，若说阅读了参考资料那也是很久之前的事情。因此觉得，这三段代码还是很有阅读价值。</strong></p>
<h3 id="非递归先序遍历"><a href="#非递归先序遍历" class="headerlink" title="非递归先序遍历"></a>非递归先序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非递归先序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrderTraverseNormal</span><span class="params">(BitTree* parent)</span> </span>&#123;</span><br><span class="line">	Stack stack;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">initStack</span>(stack) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (parent == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">push</span>(stack, *parent);</span><br><span class="line">	BitTree topNode;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">pop</span>(stack, topNode)) &#123; <span class="comment">//取栈顶元素，访问并出栈</span></span><br><span class="line">		<span class="built_in">visit</span> (node); <span class="comment">//访问栈顶元素</span></span><br><span class="line">		<span class="keyword">if</span> (topNode.right != <span class="literal">NULL</span>) &#123; <span class="comment">//存在右结点，则先将右结点入栈。因为左结点先遍历</span></span><br><span class="line">			<span class="built_in">push</span>(stack, *(topNode.right));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (topNode.left != <span class="literal">NULL</span>) &#123; <span class="comment">//存在左结点，左结点入栈</span></span><br><span class="line">			<span class="built_in">push</span>(stack, *(topNode.left));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>非递归遍历的重点是手动构造递归栈。首先将根结点入栈，然后在while循环中，先将栈顶结点出栈，并依次将该结点的右孩子结点和左孩子结点入栈（如果存在），知道栈为空pop函数返回0 结束循环。</p>
</blockquote>
<h3 id="非递归中序遍历"><a href="#非递归中序遍历" class="headerlink" title="非递归中序遍历"></a>非递归中序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非递归中序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderTraverseNormal</span><span class="params">(BitTree* parent)</span> </span>&#123;</span><br><span class="line">	Stack stack;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">initStack</span>(stack) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (parent == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">push</span>(stack, *parent);</span><br><span class="line">	BitTree topNode;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">top</span>(stack, topNode)) &#123; <span class="comment">//取栈顶结点</span></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 首先，一直遍历到最左边的结点</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">while</span> (topNode.left != <span class="literal">NULL</span>) &#123; <span class="comment">//左孩子结点不为空，入栈</span></span><br><span class="line">			<span class="built_in">push</span>(stack, *(topNode.left));<span class="comment">//左孩子结点入栈</span></span><br><span class="line">			topNode = *(topNode.left);<span class="comment">//看下一个左孩子结点</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 其次，判断其是否存在右孩子结点。</span></span><br><span class="line"><span class="comment">		 * 不存在右孩子结点，直接将该结点出栈</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (flag &amp;&amp; topNode.right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="built_in">pop</span>(stack, topNode);<span class="comment">//出栈</span></span><br><span class="line">			<span class="built_in">visit</span>(topNode);</span><br><span class="line">			flag = <span class="built_in">top</span>(stack, topNode);<span class="comment">//取栈顶结点，继续判断</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 存在右孩子结点，当前结点出栈，并将右孩子结点入栈</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">pop</span>(stack, topNode)) &#123;</span><br><span class="line">			<span class="built_in">visit</span>(topNode);</span><br><span class="line">			<span class="built_in">push</span>(stack, *(topNode.right));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>先将根结点入栈，然后根据根结点一直寻找到该左子树的最左边结点，访问该结点。如果该结点不存在右子树，直接将该结点出栈，并一直出栈到栈顶的结点存在右子树。此时将栈顶结点出栈，并将该结点的右孩子结点入栈，并寻找到该结点右子树的最左边结点。</p>
</blockquote>
<h3 id="非递归后序遍历"><a href="#非递归后序遍历" class="headerlink" title="非递归后序遍历"></a>非递归后序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非递归后序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrderTraverseNormal</span><span class="params">(BitTree* parent)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 声明两个栈，遍历树的管理栈和备用栈</span></span><br><span class="line"><span class="comment">	 * 备用栈的作用：部分结点存在两次访问的，备用栈是记录第一次访问，然后入栈。</span></span><br><span class="line"><span class="comment">	 * 也可以在结点中添加一个标签记录访问次数，备用栈的设计是为了避免修改结点</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Stack stack, backup;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">initStack</span>(stack) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">initStack</span>(backup) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (parent == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">push</span>(stack, *parent);</span><br><span class="line">	BitTree topNode; <span class="comment">//记录当前栈顶结点</span></span><br><span class="line">	BitTree backupNode; <span class="comment">//记录备用栈的栈顶结点</span></span><br><span class="line">	BitTree lastNode; <span class="comment">//上次访问的结点</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">top</span>(stack, topNode)) &#123; <span class="comment">//取栈顶结点</span></span><br><span class="line">		<span class="type">int</span> flag = <span class="built_in">top</span>(backup, backupNode); <span class="comment">//备用栈的栈顶元素,返回0表示备用栈为空。</span></span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">0</span> || <span class="built_in">compareTreeNode</span>(topNode, backupNode) == <span class="number">0</span>) &#123; <span class="comment">//该结点是第一次访问</span></span><br><span class="line">			<span class="keyword">if</span> (topNode.left != <span class="literal">NULL</span></span><br><span class="line">					&amp;&amp; <span class="built_in">compareTreeNode</span>(*(topNode.left), lastNode) == <span class="number">0</span>) &#123; <span class="comment">//左孩子结点不为空，且上次访问的不是左孩子结点</span></span><br><span class="line">				<span class="built_in">push</span>(stack, *(topNode.left)); <span class="comment">//左孩子结点入栈</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">push</span>(backup, topNode);</span><br><span class="line">			<span class="keyword">if</span> (topNode.right != <span class="literal">NULL</span></span><br><span class="line">					&amp;&amp; <span class="built_in">compareTreeNode</span>(*(topNode.right), lastNode) == <span class="number">0</span>) &#123; <span class="comment">//右孩子结点不为空，且上次访问的不是右孩子结点</span></span><br><span class="line">				<span class="built_in">push</span>(stack, *(topNode.right)); <span class="comment">//右孩子结点入栈</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">//该节结点是第二次访问，直接出栈</span></span><br><span class="line">			<span class="built_in">pop</span>(backup, backupNode); <span class="comment">//备用栈栈顶元素出栈</span></span><br><span class="line">			<span class="built_in">pop</span>(stack, topNode); <span class="comment">//当前栈栈顶元素出栈</span></span><br><span class="line">			<span class="built_in">visit</span>(topNode); <span class="comment">//访问刚出栈的结点</span></span><br><span class="line">			lastNode = topNode; <span class="comment">//记录刚刚访问的结点</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>考虑到后续遍历的特殊性质，根结点会在左孩子结点和右孩子结点出栈时访问两次。多数资料上的实现方式都是通过在每个结点中添加一个标志记录根节点的访问次数。为了维护之前定义好的结构体的完整性。用一个备用栈，完美的解决问题。</p>
</blockquote>
<blockquote>
<p>取递归栈中的栈顶元素和备用栈中的栈顶元素（如果存在）对比，如果相同，就是第二次遍历到该结点。分别将递归栈和备用栈中的栈顶元素出栈，访问并记录当前出栈的结点。如果不相同，就是第一次访问该结点，此时需要考虑当前递归栈中栈顶结点是否存在左子树或右子树以及上次出栈的结点是否是该结点的左孩子结点或右孩子结点。<br>当该结点不存在左子树或上次出栈的结点是该结点的左孩子结点，则标记当前递归栈中的栈顶结点已经访问过一次，将该结点添加到备用栈中。</p>
</blockquote>
<blockquote>
<p>说了这么多，有点绕。经过长时间的思考以及两次优化之后的成果。越是难懂的算法不一定就是最高级的算法，此处 ，不对我的代码做任何评价。</p>
</blockquote>
<h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 层次遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrderTraverse</span><span class="params">(BitTree* parent)</span> </span>&#123;</span><br><span class="line">	Queue queue = <span class="built_in">createQueue</span>();<span class="comment">//创建队列</span></span><br><span class="line">	<span class="built_in">enterQueue</span>(queue, *parent);<span class="comment">//根结点入队</span></span><br><span class="line">	BitTree node;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">exitQueue</span>(queue, node)) &#123;<span class="comment">//队列中结点出队，队列为空，返回0，while循环结束</span></span><br><span class="line">		<span class="built_in">visit</span>(child);<span class="comment">//访问队列中第一个结点</span></span><br><span class="line">		<span class="keyword">if</span> (node.left != <span class="number">0</span>)<span class="comment">//判断是否存在左孩子结点，将左孩子结点入队</span></span><br><span class="line">			<span class="built_in">enterQueue</span>(queue, *node.left);</span><br><span class="line">		<span class="keyword">if</span> (node.right != <span class="number">0</span>)<span class="comment">//判断是否存在右孩子结点，将右孩子结点入队</span></span><br><span class="line">			<span class="built_in">enterQueue</span>(queue, *node.right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>看完前面三个非递归的遍历算法，也许都晕了。层次遍历，没有递归或非递归而言，自顶向下、从左到右访问二叉树中所有的结点。先访问的结点子树上的全部结点一定比后访问结点子树上的全部结点先访问，所以层次遍历用到了队的特性。</p>
</blockquote>
<h3 id="访问结点"><a href="#访问结点" class="headerlink" title="访问结点"></a>访问结点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(BitTree node)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, node.key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这只是模拟访问结点的操作，可根据需要自定定义该函数的功能。</p>
</blockquote>
<p>上述代码中用到的栈和队列中的函数，都是复用了之前博客中介绍的栈和队列的操作函数。只是修改下每个元素的结点类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> STACK_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tree.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INIT_SIZE 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTINCREMENT 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> BitTree StackType; <span class="comment">//栈中每个元素的结点类型是二叉树</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">stackNode</span> &#123;</span><br><span class="line">	StackType *elem; <span class="comment">//存储空间基地址</span></span><br><span class="line">	<span class="type">int</span> length; <span class="comment">//当前长度</span></span><br><span class="line">	<span class="type">int</span> listsize; <span class="comment">//当前分配的存储容量（以sizeof(ElemType)为单位）</span></span><br><span class="line">&#125;Stack;</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> QUEUE_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUEUE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tree.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> BitTree QueueType;<span class="comment">//队列中每个元素的结点类型是二叉树</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LinkQueue</span> &#123;</span><br><span class="line">	QueueType key;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LinkQueue</span> *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">queueNode</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LinkQueue</span> *head; <span class="comment">//队列的头指针</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LinkQueue</span> *end; <span class="comment">//队列的尾指针</span></span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>最后，附上头文件的定义，部分方法未实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * tree.h</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Created on: 2016年9月25日</span></span><br><span class="line"><span class="comment"> *      Author: flueky</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stack.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;queue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TREE_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TREE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> TreeType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BitNode</span> &#123;</span><br><span class="line">	TreeType key;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BitNode</span> *left;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BitNode</span> *right;</span><br><span class="line">&#125; BitTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造空二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initBitTree</span><span class="params">(BitTree&amp;)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 销毁二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destoryBitTree</span><span class="params">(BitTree&amp;)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createBitTree</span><span class="params">(BitTree**)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将二叉树清为空树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearBitTree</span><span class="params">(BitTree&amp;)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归先序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrderTraverse</span><span class="params">(BitTree*)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非递归先序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrderTraverseNormal</span><span class="params">(BitTree*)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归中序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderTraverse</span><span class="params">(BitTree*)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非递归中序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderTraverseNormal</span><span class="params">(BitTree*)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归后序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrderTraverse</span><span class="params">(BitTree*)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非递归后序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrderTraverseNormal</span><span class="params">(BitTree*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 层次遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrderTraverse</span><span class="params">(BitTree*)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 比较两个结点，相同返回1，不同返回0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compareTreeNode</span><span class="params">(BitTree, BitTree)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(BitTree)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TREE_H_ */</span></span></span><br></pre></td></tr></table></figure></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">flueky</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/227/">http://example.com/227/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/228/"><i class="fa fa-chevron-left">  </i><span>不是安卓工程师，也能看logcat日志</span></a></div><div class="next-post pull-right"><a href="/226/"><span>数据结构（四）——队列（C语言实现）</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2016 - 2024 By flueky</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>